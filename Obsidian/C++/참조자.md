C 언어에서는 어떠한 변수를 가리키고 싶을 때 반드시 포인터를 사용해야했지만, C++에서는 변수나 상수를 가리키는 또 다 방법으로 **참조자**라는 방식을 제공한다.

참조자의 선언은 다음과 같이 타입의 뒤에 &를 붙이면 되며, 포인터의 참조자 또한 생성 가능하다.

```cpp
int a;
int& another_a = a;

int* b;
int*& another_b = b;
```

어떻게 보면 참조자와 포인터는 상당히 유사한 개념이다.

포인터 또한 다른 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산할 수 있기 때문이다.

하지만 참조자와 포인터는 몇 가지 중요한 차이점이 있다.

- 참조자는 정의 시에 반드시 어떤 것을 참조하는지를 명시해야 하지만, 포인터는 전혀 문제가 없다.
    
    ```cpp
    int& another; // 불가능
    int* p; // 가능
    ```
    
- 참조자는 한 번 참조할 것이 결정되면 절대로 다른 것을 참조할 수 없다.
    
    ```cpp
    int a = 10;
    int& another = a;
    
    int b = 20;
    // 참조자를 바꾸는 것이 아닌 a에 b를 대입하라는 의미
    another = b;
    ```
    
- 참조자는 메모리 상에 존재하지 않을 수도 있다.
    
    ```cpp
    int a = 10;
    int& another = a;
    ```
    
    굳이 참조자를 메모리 상에 할 당할 필요 없이 another를 a로 치환하면되기 때문에 참조자는 메모리 상에 존재하지 않게 된다.
    
    하지만 함수의 인자로 참조자를 받는 경우에는 메모리 상에 존재하게 된다.
    

참조자는 상수를 참조할 수 없지만, const를 사용하면 상수의 참조가 가능해 지며, 리터럴 상수 또한 참조가 가능해진다.

```cpp
const int x = 100;
const int& another = x;
const int& another1 = 100;
```

- 상수를 const 참조자로 참조하면 임시 변수라는 것이 생기면서 리터럴 상수도 참조가 가능해 진다.

참조자의 배열은 언어 차원에서 불가능하도록 해 놓았다.

배열은 첫번째 원소의 주소값이 있어야 하지만, 주소값이 있다는건 메모리에 존재한다는 것이다. 참조자는 특별한 경우를 제외하면 메모리에 조재하지 않기 때문에 배열의 선언이 되지 않는다.

참조자 배열은 되지 않지만, 배열을 참조하는 것은 가능하다.

```cpp
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&another)[3] = arr;
}
```

참조자를 함수의 반환형으로도 사용할 수 있다.

먼저 지역 변수를 리턴하는 경우를 보면 리턴과 동시에 지역 변수가 소멸하기 때문에(참조하던 것이 사라진 참조자를 댕글링 레퍼런스(Dangling reference)라고 한다) 런타임 에러가 발생한다. 하지만 인자로 참조자를 받아온걸 리턴한다면 정상적으로 동작한다.

```cpp
int& function(int& a) {
  a = 5;
  return a;
}

int main() {
  int b = 2;
  int c = function(b);
  return 0;
}
```

참조자는 리턴 값 또한 참조할 수 있는데, const를 사용하면 가능해진다.