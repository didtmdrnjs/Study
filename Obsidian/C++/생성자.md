생성자는 객체가 생성될 때 자동으로 호출되는 함수이며 다음과 같이 선언한다.

```cpp
class TempClass {
public:
	// 생성자
	TempClass(/* 인자 */) {
	
	}
};
```

이렇게 선언한 생성자는 암시적 방법과 명시적 방법으로 호출할 수 있다.

```cpp
TempClass temp(/* 인자 */);  // 암시적 방법
TempClass temp = TempClass(/* 인자 */);  // 명시적 방법
```

### 디폴트 생성자(Default Constructor)

디폴트 생성자는 인자를 하나도 가지지 않는 생성자이며, 클래스에서 사용자가 어떠한 생성자도 명시적으로 정의하지 않은 경우 컴파일러가 자동으로 추가해 준다.

디폴트 생성자는 다음과 같이 호출할 수 있다.

```cpp
TempClass temp = TempClass();
TempClass temp;
```

C++11 이전에는 디폴트 생성자를 사용하려면, 생성자 자체를 정의하지 않아야 했지만 C++11 부터 명시적으로 디폴트 생성자를 정의할 수 있게 되었다.

```cpp
class TempClass {
public:
	TempClass() = default;
};
```

그리고 생성자도 함수이기 때문에 생성자 오버로딩 또한 가능하다.

```cpp
class TempClass {
public:
	TempClass() {
	
	}
	
	TempClass(int a) {
	
	}
	
	TempClass(float a) {
	
	}
};
```

## 복사 생성자

복사 생성자는 클래스의 다른 객체를 상수 참조자로 받는 생성자이다.

```cpp
class TempClass {
public:
	TempClass(int _x, int _y);
	TempClass(const TempClass& tc);
};
```

복사 생성자는 다음과 같이 호출할 수 있다.

```cpp
TempClass temp1(1, 2);

TempClass temp2(temp1);

// 이것도 가능하다.
TempClass temp2 = temp1;

// TempClass temp2;
// temp2 = temp1; 은 그냥 대입 연산이다
```

복사 생성자 또한 디폴트 복사 생성자가 존재한다.

만약 클래스에 포인터가 있을 때 디폴트 복사 생성자를 사용하게 되면, 런타임 에러가 날 것이다.

메모리를 새로 할당해서 내용을 복사하는 것을 깊은 복사, 단순히 대입만 해주는 것을 얕은 복사라고 하는데, 디폴트 복사 생성자는 얕은 복사밖에 하지 못하기 때문에 두 포인터가 하나의 주소를 가리키게 된다.

둘 중 하나의 객체가 소멸하게 되면 해당 포인터가 참조하던 메모리 또한 해제가 되는데, 이때 다른 포인터가 이미 해제된 메모리를 참조하기 때문에 에러가 난다.

### 생성자 초기화 리스트(Initializer list)

생성자 호출과 동시에 멤버 변수들을 초기화 해준다.

다음과 같이 사용한다.

```cpp
TempClass::TempClass() : x(1), y(0.5), z(false) {

}

// 이것도 됨
TempClass::TempClass(int x) : x(x) {

}
```

생성자 초기화 리스트를 사용하는 이유는 다음과 같다.
생성자 초기화 리스트를 사용하면 생성과 초기화를 동시에 진행한다.
그리고 상수와 참조자는 생성과 동시에 초기화 되어야 하기 때문 클래스에 상수와 참조자가 있다면 반드시 생성자 초기화 리스트를 사용하여 초기화 해야 한다.

