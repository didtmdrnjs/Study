**B*Tree 인덱스 구조**

- 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다.
- 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다.
- 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
- 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다.
- 리프 블록의 각 로우와 테이블 로우 간에는 1 : 1 관계다.
- 리프 블록끼리는 이중연결리스트 구조다.

**인덱스 ROWID**

ROWID는 (데이터파일 번호 + 블록 번호 + 블록 내 로우 번호)로 구성된다.

- 확장 ROWID 포맷은 맨 앞에 오브젝트 번호가 추가된다.

**인덱스 탐색**

수직적 탐색을 통해 조건을 만족하는 스캔 시작 지점을 찾으며, 수평적 탐색을 진행하면서 내가 찾는 데이터가 더 안나올 때까지 리프 노드를 스캔한다.

**SQL Server에서의 Index 선택 힌트**

일반적으로 다음과 같은 방식을 사용한다.

```sql
DECLARE @CUST_NO INT

SELECT * 
FROM 고객 WITH(INDEX(고객_PK))
WHERE 고객번호 = @CUST_NO

SELECT * 
FROM 고객 WITH(INDEX=고객_PK)
WHERE 고객번호 = @CUST_NO
```

다음과 같은 방식도 있다.

```sql
SELECT * 
FROM 고객 WITH(FORCESEEK(고객_PK(고객번호)))
WHERE 고객번호 = @CUST_NO

// 테이블을 Full Scan 한다.
SELECT * 
FROM 고객 WITH(FORCESCAN)
WHERE 고객번호 = @CUST_NO

// 1로 지정하면 클러스터형 인덱스를 검색한다.
// 0으로 지정하면 클러스터형 인덱스를 Scan 하면서 고객번호를 필터링한다.
// 여기서 만약 클러스터형 인덱스가 없으면 0으로 지정했을 때 테이블을 Full Scan하고,
// 1이면 구문 오류가 발생한다.
SELECT * 
FROM 고객 WITH(INDEX(1))
WHERE 고객번호 = @CUST_NO

SELECT * 
FROM 고객
WHERE 고객번호 = @CUST_NO
OPTION (TABLE HINT(고객, INDEX(고객_PK)))
```

**Index Range Scan**

- WHERE 절에 인덱스 선두컬럼에 대한 조건이 반드시 있어야 하지만, ‘=’ 조건일 필요는 없다.
- 부등호, BETWEEN, LIKE 등 모두 가능하다.

**Index Full Scan**

- 리프 블록을 처음부터 끝까지 모두 스캔하는 방식이며, 인덱스 선두 컬럼이 조건절에 없을 때 사용된다.
- 조건을 만족하는 데이터가 적어야 효율적이다.
- 조건을 만족하는 데이터가 많아도 부분범위처리를 할 수 있으면, 효과적일 수 있다.

**Index Unique Scan**

- 인덱스 구성 컬럼을 모두 ‘=’ 조건으로 검색하면 Index Unique Scan이 선택된다.
- ‘=’ 조건이 인덱스 컬럼의 일부라면 Index Range Scan이 선택된다.

**Index Fast Full Scan**

- 리프 블록의 물리적 순서를 따르므로 결과 집합의 순서는 보장하지 않는다.
- Multiblock I/O 방식을 사용한다.
- 병렬 스캔도 가능하다.
- 인덱스에 포함된 컬럼으로만 조회할 때 사용할 수 있다.

**Index Skip Scan**

- 인덱스 선두 컬럼이 조건절에 없을 때 사용할 수 있는 스캔 방식 중 하나다.
- 인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
- index_ss 힌트로 유도한다.
- 선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위 검색 조건일 때도 사용할 수 있다.

**Index Fragmentation**

- Index Skew
    - 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상
- Index Sparse
    - 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상

**비트맵(Bitmap) 인덱스**

- Distinct Value 개수가 적을 때 저장효율이 매우 좋다.
- 대용량 테이블에 유용하다.
- 여러 인덱스를 동시에 사용할 수 있으며, 여러 개의 비트맵 인덱스로 Bitwise 연산을 수행함으로써 테이블 액세스량을 크게 줄일 수 있다면 극적인 성능 향상을 가져다 준다.
- 다양한 조건절과 정형화되지 않은 임의 질의가 많은 대용량 DW/OLTP 환경에 적합하다.
- Lock에 의한 DML 부하가 심하다.
- 따라서 읽기 위주의 대용량 DW(특히 OLTP) 환경에 사용한다.

**함수기반(Function Based) 인덱스**

조건절에서 인덱스 컬럼에 함수를 적용하면 Index Range Scan이 불가능한데, 인덱스에도 함수를 적용한 상태로 값을 저장해서 정상적인 Index Range Scan이 가능하도록 한다.

**리버스 키(Reverse Key) 인덱스**

오름차순 한 방향으로만 값이 증가하는 컬럼에 인덱스를 생성하면, 동시에 INSERT 하려는 다중 트랜잭션에 의해 맨 우측 리프 블록에 경합이 발생할 수 있다.

이럴 때 인덱스 키 값을 역으로 변환해서 저장해 신규로 INSERT하는 값들이 여러 리프 블록에 흩어지게하는 방식이다.

**인덱스를 이용한 테이블 랜덤 액세스 감소**

- IOT
    - 테이블을 인덱스 구조로 관리한다.
    - 지정한 키 값 순으로 정렬 상태를 유지한다.
    - 키 값 이외의 값도 모두 리프 블록에 저장하므로 랜덤액세스가 전혀 발생하지 않는다.
    - 테이블에 한 개만 생성할 수 있다.
- 클러스터
    - 값이 같은 레코드를 한 블록에 모아서 저장하므로 인덱스를 이용한 테이블 랜덤 액세스를 줄이는 데 도움을 준다.
- 테이블 파티션
    - 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장한다.
    - 특정 조건을 만족하는 데이터를 인덱스를 이용한 랜덤 액세스가 아닌 Full Scan 방식으로 빠르게 찾을 수 있다.

**Index Range Scan 불가 조건**

- 중간 값 검색(양쪽 % LIKE 조건)
- 부정형 조건
- 인덱스 컬럼 변형

**IS NULL 조건에 대한 Index Range Scan**

오라클은 구성 컬럼이 모두 NULL인 레코드는 인덱스에 저장하지 않는다.

따라서 단일 컬럼에 생성한 인덱스에 대한 IS NULL 조건으로는 Index Range Scan이 불가능하다.

2개 이상 컬럼으로 구성된 결합 인덱스에 대해서는 IS NULL 조건에 대한 Index Range Scan이 가능 할 수 있다.

**Index Range Scan 가능 조건**

선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

하지만 인덱스를 Range Scan 한다고 반드시 성능이 좋은 것은 아니다.

**OR 조건에 대한 Index Range Scan**

OR 족너은 기본적으로 index Range Scan을 위한 애세스 조건으로 사용할 수 없지만, CONCATENATION(옵티마이저에 의한 UNION ALL 분기)으로 처리했을 때 각각 수직 탐색을 위한 액세스 조건으로 사용할 인덱스가 있다면 Index Range Scan이 가능하다.