**파티셔닝의 이점**

- 성능 향상
- 경합 분산
- 백업 및 복구
- 대량 데이터 변경 및 삭제
- 가용성 향상

**Range 파티션**

- 파티션 기준으로 여러 컬럼으 선택할 수 있으며, 문자형 컬럼도 선택할 수 있다.
- 입력공간을 찾지 못해 에러가 발생하는 것을 방지하려면 MAXVALUE 파티션을 추가해야 한다.

**List 파티션**

- 단일 컬럼으로만 파티션 가능
- List 파티션에 대한 Pruning은 BETWEEN 조건일 때도 작동함

**Hash 파티션**

Range, List 파티션은 파티션 기준을 사용자가 직접 지정하므로 특정 파티션에 데이터가 몰리지 않도록 구성할 수 있다. 하지만 Hash 파티션은 DBMS가 정한 해시 알고지즘에 따라 임의로 데이터를 분할하므로 값의 분포가 고르지 않을 때 특정 파티션에 데이터가 몰리는 현상이 생길 수 있다.

**Pruning**

- 파티셔닝을 통해 SQL 성능을 향상해 주는 핵심원리는 파티션 Pruning에 있다
- Static 파티션 Pruning
    - 파티션 키 컬럼을 상수 조건으로 조회하는 경우에 작동하며, 액세스할 파티션이 쿼리 최적화 시점에 미리 결정되는 것이 특징이다.
    - 실행계획(Pstart(partition start)와 Pstop(partition stop) 컬럼에는 액세스할 파티션 번호가 출력된다.
- Dynamic 파티션 Pruning
    - 파티션 키 컬럼을 바인드 변수로 조회하면 쿼리 최적화 시점에는 액세스할 파티션을 미리 결정할 수 없다.
    - 실행 시점이 돼서야 사용자가 입력한 값에 따라 결정되며, 실행계획의 Pstart와 Pstop 컬럼에는 ‘KEY’라고 표시된다.
    - NL 조인할 때도 Inner 테이블이 조인 컬럼 기준으로 파티셔닝 돼 있다면 동적이 작동한다.
- 고급 파티션 Pruning에는 서브쿼리 Pruning과 조인 필터(=블룸 필터) Pruning이 있다.
- 인덱스 컬럼을 가공하면 인덱스 Range Scan이 불가능한 것처럼 파티션 컬럼을 가공하면 파티션 Pruning이 불가능하다.
    - 파티션 Pruning이 불가능하면 실행계획에 ‘PARTITION RANGE ALL’ 오퍼레이션이 나타난다.
- 파티션 키 컬럼에는 Like보다 Between을 사용하는 것이 좋다.

**Local 파티션 인덱스**

Local 파티션 인덱스는 테이블 파티션 속성을 그대로 상속받는다.

따라서 테이블 파티션 키가 주문일시면 인덱스 파티션 키도 주문일시가 된다.

Local 파티션 인덱스는 테이블과 정확히 1:1 대응 관계를 갖도록 오라클이 파티션을 자동으로 관리해 준다.

테이블 파티션 구성을 변경(add, drop, exchange 등)하더라도 인덱스를 재생성할 필요가 없다.

변경작업이 순식간에 끝나므로 피크(peak) 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다.

**Global 파티션 인덱스**

파티션을 테이블과 다르게 구성한 인덱스다.

구체적으로, 파티션 유형이 다르거나, 파티션 키가 다르거나, 파티션 기준값 정의가 다른 경우다.

비파티션 테이블이어도 인덱스는 파티셔닝할 수 있다.

글로벌 파티션 인덱스는 테이블 파티션 구성을 변경(DROP, EXCHANGE, SPLIT 등) 하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다.