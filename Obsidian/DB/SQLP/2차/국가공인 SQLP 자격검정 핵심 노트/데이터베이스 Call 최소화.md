**데이터베이스 Call**

- 애플리케이션 커서를 캐싱하지 않는 한, Parse Call은 바인드 변수를 사용해도 매번 일어난다.
- Parse Call 단계에서 하드 파싱을 하게 되면 딕셔너리를 조회하는 과정에 Recursive Call이 발생한다.
- DML은 Parse Call 단계를 제외하면 모든 I/O가 Execute Call 단계에서 일어난다.
- SELECT 문을 대부분 I/O가 Fetch Call 단계에서 일어난다.
- DB 저장형 프로시저는 Execute Call 단계에서 수행되며, 그안에 내장된 SQL을 실행할 때 Recursive Call이 발생한다.
- select 문에 사용한 DB 저장형 함수는 (Execute 단계에서 수행되는 일부 예외 케이스를 제외하면) 대부분 Fetch 단계에서 수행된다. DB 저장형 함수에 내장된 SQL을 실행할 때 Recursive Call이 발생한다.
- User Call은 네트워크를 경유하므로 Recursive Call보다 성능 부하가 훨씬 더 크다.

**데이터베이스 Call을 줄이는 방안**

- Array Size를 늘린다.
- Array Processing을 활용한다.
- 전체 결과집합을 한 번에 출력하지 않고 페이징 처리 기법을 활용한다.

**Array Processing**

- 데이터베이스 Call을 줄이는게 핵심원리이다.
- Java같은 프로그램에는 성능개선효과가 크다.
- Array 단위를 늘리면 성능은 좋아지지만 개선율은 낮아진다.
- 효과를 극대화하려면 연속된 일련의 과정을 모두 Array 단위로 처리해야 한다.

**Fetch Call을 줄이는 법**

- 부분범위 처리를 활용한다.
- 화면 페이징 처리 기법 활용한다.
- Array Size를 늘린다.

**부분범위 처리**

서버 프로세스가 쿼리 결과집합을 한 번에 모두 전송하지 않고 클라이언트로부터 Fetch Call이 올 때마다 일정량씩 나눠서 전송하는 것이다.

**Full Table Scan할 때 I/O 횟수**

- Multiblock I/O를 작게 설정할수록 늘고, 크게설정할수록 줄어든다.
- 익스텐트가 작은 것들로 구성되있으면 I/O Call이 많다.
- Array Size를 작게 설정하면 한 블록을 여러번 읽는다.

**저장형 함수 성능이 저하의 해결 방안**

- C, Java, VB 등 애플리케이션 함수로 전환하면, Recursive Call 대신 User Call이 발생하므로 성능이 더 안 좋다.
- CASE 문이나 조인문을 활용함으로써 DB 저장형 함수를 제거한다면, 함수 호출 및 Recursive Call이 발생하지 않으므로 성능 개선에 큰 도움이 된다.
- Deterministic 함수로 전환하면 캐싱 효과가 나타난다.
- 함수에서 참조하는 테이블 데이터가 자주 변하지 않는다면, Result 캐시 기능도 도움이 된다.

**결과 집합이 평균 10만건 이내인 쿼리의 튜닝**

- 부분범위 처리를 활용하면 함수 호출 부하를 최소화할 수 있다. 부분범위 처리를 활용하려면 소트 연산을 생략할 수 있어야 하는데, 이를 위해 SQL에서 ORDER BY를 제거할 필요는 없다.
- 페이징 처리 활용도 함수 호출 부하를 최소화하는 데 큰 도움이 된다.
- 함수에 스칼라 서브쿼리를 씌워서 실행하면 함수 호출 부하를 줄이는 데 큰 도움이 된다. 스칼라 서브쿼리에 캐싱 기능이 작동하기 때문이다. 단, 함수에 입력하는 값 종류가 많지 않아야 한다.
- 함수를 풀어서 조인문으로 변경하는 것이 함수 호출 부하를 줄이는 근본적인 해법이다. 조인으로 변경할 경우, NL 조인이 가장 효과적이다. 부분범위 처리가 가장 잘 작동하기 때문이다.

**저장형 함수에 내장된 SQL에 대한 Recursive Call 횟수를 줄이는 방안**

- 스칼라 서브쿼리를 이용한 함수 결과 캐싱
- Deterministic 함수 캐싱
- Result 캐시
- Native 컴파일
- 이 순으로 효과가 크다.

**저장형 함수의 읽기 일관성 이슈**

코드명, 상품명 등을 조회할 때 함수를 사용하지않고, 스칼라 서브쿼리로 조인하면 일관성이 보장된다.