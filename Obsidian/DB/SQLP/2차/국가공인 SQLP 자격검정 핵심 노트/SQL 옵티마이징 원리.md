**비용기반 옵티마이저**

- 사용자 쿼리를 위해 후보군이 될만한 실행계획들을 도출한다.
- 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행 계획의 예상비용을 산정하고 그 중 가장 낮은 비용의 실행계획의 예상비용을 산정하고, 그 중 가장 비용이 낮은 실행계획을 하나 선택한다.
    - 통계정보
        - 데이터 양
        - 컬럼 값의 수
        - 컬럼 값 분포
        - 인덱스 높이
        - 클러스터링 팩터

**규칙기반 옵티마이저**

- 각 액세스 경로에 대한 우선순위 규칙에 따라 실행계획을 만드는 옵티마이저
- 통계정보를 전혀 활용하지 않고, 단순한 규칙에만 의존한다.
- 인덱스 구조, 연산자, 조건절 형태가 순위를 결정하는 주요소이다.

**옵티마이저 서브 엔진**

- Query Transformer
    - 사용자로부터 전달받은 SQL을 그래로 최적화하지 않고 우선 최적화에 유리한 형태로 형태변환을 시도한다.
- Estimator
    - 쿼리 오퍼레이션 각 단계와 선택도, 카디널리티, 비용을 계산하고, 궁극적으로는 실행계획 전체에 대한 총 비용을 계산해 낸다.
- Plan Generator
    - 하나의 쿼리를 수행하는데 있어, 후보군이 될만한 실행계획들을 생성해 낸다.

**옵티마이저가 힌트를 무시하는 경우**

- 문법적으로 맞지 않게 힌트를 기술
- 잘못된 참조 사용
- 논리적으로 불가능한 액세스 경로
- 의미적으로 맞지 않게 힌트를 기술
- 옵티마이저에 의해 내부적으로 쿼리가 변환된 경우
- 버그

**스스로 학습하는 옵티마이저 기능**

- Adaptive Cursor Sharing
    - 바인드 변수에 다른 값이 입력됐을 때 예상보다 많은 I/O가 발생하면 다른 실행계획을 추가로 생성하고, 이후로 바인드 변수 값 분포에 따라 다른 실행계획을 선택적으로 사용한다.
- Statistics Feedback(Cardinality Feedback)
    - 최초 실행 계획을 수립할 떄 추정했던 카디널리티의 실제 실행 과젱에 읽은 로우 수들 간에 차이가 크다고 판단 되면 조정된 카디널리티 값을 어딘가에 저장해 두었다가 다음번 실행 시에 그것을 사용합으로써 다른 실행 계획이 수립되도록 한다.
- Adaptive Plans
    - 런타임에 실행계획을 변경 하는 기능들을 포함한다.

**통계정보**

- 오브젝트 통계
    - 테이블 통계(레코드 수, 블록 수, 평균 행 길이 등)
    - 인덱스 통계(인덱스 높이, 리프 블록 개수, 클로스터링 팩터 등)
    - 컬럼 통계(중복을 제거한 컬럼 값의 수, 최소값, 최대값, Null 값 개수, 히스토그램 등)
- 시스템 통계
    - CPU 속도
    - Single Block I/O 속도
    - Multiblock I/O 속도
    - 평균적인 Multiblock I/O 개수

**옵티마이저 행동에 영향을 미치는 요소**

- 옵티마이징 팩터 : 인덱스, IOT, 클러스터링, 파티셔닝 등 오브젝트 구성
- DBMS 제약 설정 : PK, FK, Check, Not Null 등
- 통계정보
- 옵티마이저 힌트
- 옵티마이저 관련 파라미터

**옵티마이저의 한계**

- 부족한 옵티마이징 팩터 : 인덱스, IOT, 클러스터링, 파티셔닝 등 오브젝트 구성
- 부정확한 통계 : 정보 수집 및 보관 비용 측면의 한계(샘플링 비율, 수집 주기 등)
- 결합 선택도 산정의 어려움
- 바인드 변수 사용시, 히스토그램 사용에 제약 : 균등분포 가정
- 비현실적인 가정과 규칙에 의존
- 최적화 시간에 허용된 시간 제약

**선택도와 카디널리티**

- ‘=’ 조건으로만 검색하는 경우
    - 선택도 = 1 / NDV
    - 카디널리티 = 총 로우 수 / NDV

**컬럼 통계**

- 중복을 제거한 컬럼 값의 수(num_distinct)
- 최소값(low_value)
- 최대값(high_value)
- 밀도(density)
- 평균 컬럼 길이(avg_col_len)
- NULL 값을 가진 레코드 수(num_nulls)

**시스템 통계**

- CPU 속도
- 평균적인 Single Block I/O 속도
- 평균적인 Multiblock I/O 속도
- 평균적이 Multiblock I/O 개수
- I/O 서브시스템의 최대 처리량(Throughput)
- 병렬 Slave의 평균적인 처리량(Throughput)

**I/O 비용 모델 vs CPU 비용 모델**

- I/O 비용 모델 : 예상되는 디스크 I/O Call 횟수
- CPU 비용 모델 : 예상 I/O 시간과 예상 CPU 사용 시간을 Single Block I/O 시간으로 나눈 값

**히스토그램 유형**

- 도수분포(Frequency) : 값별로 빈도수 저장
- 높이균형(Height-Balanced) : 각 버킷의 높이가 동일하도록 데이터 분포 관리
- 상위도수분포(Top-Frequency) : 많은 레코드를 가진 상위 n개 값의 빈도수 저장
- 하이브리드(Hybrid) : 도수분포와 높이균형 히스토그램의 톡성을 결합

**인덱스를 이용한 테이블 액세스 비용**

- 비용 = 브랜치 레벨 + (리프 블록 수 * 유효 인덱스 선택도) + (클러스터링 팩터 * 유효테이블 선택도)