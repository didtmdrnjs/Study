데이터베이스(Database)

- 오라클은 물리적인 OS 파일의 집합(디스크에 저장된 데이터 집합)이라 정의하였다.
- Datafile, Redo Log File, Control File 등

인스턴스(Instance)

- SGA 공유 메모리 영역과 이를 액세스하는 프로세스 집합
- RAC(Real Application Cluster) 환경에서는 여러 인스턴스가 하나의 데이터베이스를 액세스할 수 있다.

### 백그라운드 프로세스

- System Monitor (SMON) : 장애가 발생한 시스템을 재기동할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링한다.
- Process Monitor (PMON) : 이상이 생긴 프로세스가 사용하던 리소스를 복구한다.
- Database Writers (DBWn) : 버퍼캐시에 있는 Dirty 버퍼를 데이터파일에 기록한다.
- Log Writer (LGWR) : 로그 버퍼 엔트리를 Redo 로그 파일에 기록한다.
- Archiver (ARCn) : 꽉 찬 Redo 로그가 덮어 쓰여지기 전에 Archive 로그 디렉토리로 백업한다.
- Checkpoint (CKPT) : Checkpoint가 일어난 마지막 시점 이후의 변경사항을 데이터파일에 기록하도록하고, 기록이 끝나면 어디까지 기록했는지를 컨트롤 파일과 데이터파일 헤더에 저장한다.
    - Write Ahead Logging 방식(데이터 변경 전에 로그부터 남김)을 사용하는 DBMS는 체크포인트 정보(Redo 로그에 기록한 변경사항 중 어디까지 기록했는지)를 관리해야하며, 이는 버퍼 캐시와 데이터파일이 동기화된 시점을 가리진다.
    - 장애가 발생하면 마지막 체크 포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스를 복구할 수 있도록하는 용도로 사용된다.
- Recoverer (RECO) : 분산 트랜잭션 과정에 발생한 문제를 해결한다.

### 데이터 저장 구조

- 블록(=페이지)
    - 대부분 DBMS는 블록단위로 I/O한다.
    - 하나의 레코드에서 하나의 컬럼만 읽어도 그것 속한 블록을 읽는다.
- 익스텐트
    - 공간을 확장하는 단위
    - 공간이 부족해지면 오브젝트가 속한 테이블스페이스로부터 추가적인 공간을 할당받는데, 이때 정해진 익스텐트 크기의 연속된 블록을 할당받는다.
- 세그먼트
    - 데이터 저장공간을 사용하는 오브젝트(테이블, 인덱스, 파티션, 클러스터, LOB 등)
        - 저장공간을 사용하지 않는 오브젝트(뷰, 시너님, 시퀀스, 함수, 프로시저, 트리거)와 구분해서 세그먼트라 부른다.
        - 저장공간을 쓴다는 것은 테이블스페이스로부터 한 개 이상의 익스텐트를 할당받는 것을 뜻한다.
    - 익스텐트의 집합이며, 익스텐트끼리는 인접하지 않는다.
- 테이블스페이스
    - 세그먼트를 담는 컨테이너로, 여러 데이터파일로 구성된다.
    - 테이블스페이스와 세그먼트는 1 : M 관계이다.
    - 한 세그먼트는 여러 데이터 파일에 걸쳐 저장된다.

### Undo 사용 목적

- Transaction Rollback
- Transaction Recovery
- Read Consistency

### Redo 로그 사용 목적

- Database Recovery(=Media Recovery)
    - 물리적으로 디스크에 결함이 생기는 등 Media Fail 발생 시 데이터베이스 복구를 위해 사용
    - Archived Redo 로그를 이용한다.
- Cache Recovery
    - 캐시에만 적용한 변경사항을 아직 데이터파일에 기록하지 않은 상태에서 인스턴스가 비정상적으로 종료되었을 때, 트랜잭션 데이터 유실을 대비하기 위해 사용
- Fast Commit
    - 변경된 메모리 버퍼 블록을 데이터파일에 기록하는 작업을 Random 액세스로 하기 때문에 느리므로, 먼저 Append 방식으로 로그 파일에 빠르게 기록하고 DBWR을 이용해 나중에 일괄 수행하는 방식을 사용한다.

### Redo 메커니즘

- Log Force at commit
    - 트랜잭션의 영속성을 보장하기 위해, 최소한 커밋 시점에는 로그를 데이터파일위에 기록해야 한다.
- Fast Commit
    - 커밋 정보가 로그파일에 기록돼 있기만 하면, 인스턴스가 Crash가 발생하더라도 언제든지 복구 가능하므로 안심할 수 있다.
    - 갱신 사항을 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록하지 않았더라도 Redo 로그를 믿고 빠르게 커밋을 완료한다.
- Write Ahead Logging
    - 버퍼캐시 블록을 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 한다.
    - DBWR이 버퍼캐시의 Dirty 블록들을 데이터파일에 기록하기 전에 먼저 LGWR이 해당 Redo 엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야 한다.

### 메모리 캐시

- DB 버퍼 캐시 : 테이블 블록, 인덱스 블록, Undo 블록을 캐싱
- 라이브러리 캐시 : SQL, DB 저장형 함수/프로시저, 트리거를 캐싱
- 딕셔너리 캐시 : 테이블 정보, 인덱스 정보, 데이터파일 정보, 시퀀스 등을 캐싱
- 결과 캐시 : SQL 결과 집합을 캐싱

### 버퍼 블록의 상태

모든 버퍼캐시 블록은 아래 세 가지 중 하나의 상태에 놓인다.

- Free 버퍼
    - Clean 버퍼(인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는 상태)이거나, 데이터가 담겼지만 데이터파일과 서로 동기화돼 있는 상태여서 언제든지 덮어 써도 무방한 버퍼 블록
    - 오라클이 데이터파일로부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 한다.
    - Free 상태인 버퍼에 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀐다.
- Dirty 버퍼
    - 버퍼캐시에 적재된 이후 변경이 발생했지만, 아직 데이터파일에 기록하지 않아 동기화가 필요한 버퍼 블록
    - 이 버퍼 블록들을 다른 데이터 블록을 위해 재사용하려면 데이터파일에 먼저 기록해야한다.
    - 데이터파일에 기록한 순가 Free 버퍼로 상태가 바뀐다.
- Pinned 버퍼
    - 읽기 또는 쓰기 작업을 위해 현재 액세스되고 있는 버퍼 블록을 말한다.