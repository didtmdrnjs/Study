**인덱스 ROWID를 이용한 테이블 액세스**

인덱스 ROWID는 테이블 레코드와 직접 연결된 구조가 아니다.

데이터파일 상에서 테이블 레코드를 찾아가기 위한 논리적인 주소 정보다.

인덱스 ROWID에 포함된 데이터 블록 주소(데이터 파일 번호 + 블록 번호)는 디스크 상의 블록 주소지만, 블록을 매번 데이터파일에서 읽으면 성능은 당연히 느려질 것이기 때문에 I/O 성능을 위해 버퍼캐시 활용이 필수이다.

버퍼캐시는 시스템 공유 메모리에 위치하므로 액세스를 직력화하기 위한 Lock 메커니즘이 작동한다.따라서 인덱스 ROWID를 이용한 테이블 액세스는 고비용 구조다.

**클러스터링 팩터**

인덱스 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여 있는 정도를 의미한다.

통계정보의 일종으로서 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 미리 구해 놓은 값이다.

인덱스 성능은 클러스터링 팩터가 테이블 블록 수에 가까울수록 좋고, 테이블 레코드 수에 가까울수록 나쁘다.

**인덱스 손익분기점**

인덱스 클러스터링 팩터가 좋으면 테이블 액세스 과정에 방생하는 블록 I/O가 잠소하므로 같은 양의 데이터를 추출하더라도 CF가 나쁠 때보다 소요 시간이 줄어든다.

따라서 그래프에서 인덱스 ROWID를 이용한 테이블 액세스의 경사가 완만해지면서 손익분기점이 올라간다.(그래프에서 우측으로 이동한다)

반대로, CF가 나쁘면 인덱스 ROWID를 이용한 테이블 액세스의 경사가 가팔라지면서 인덱스 손익분기점이 내려간다.(그래프에서 좌측으로 이동한다)

Multiblock I/O 단위를 늘릴수록 디스크 I/O Call 횟수가 줄고 테이블 전체 스캔 비용이 낮아지므로 소요시간이 줄어든다. 따라서 인덱스 손익분기점이 내려간다.(그래프에서 좌측으로 이동)

일정량 이상의 데이터를 읽을 때 인덱스 효용성이 낮은 이유는 인덱스를 이용한 테이블 액세스가 랜덤 방식인 데다 Single Block I/O 방식으로 디스크 블록을 읽기 때문이다.

**온라인 프로그램 튜닝 vs 배치 프로그램 튜닝**

온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다. 조인도 대부분 NL 방식을 사용한다.

인덱스를 이용해 소트연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면, 온라인 환경에서 대량 데이터를 조회할 때도 아주 빠른 응답속도를 낼 수 있다.

반면, 대량 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다. 즉, 처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼야한다.

대량 데이터를 빠르게 처리하려면 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다.

부분 범위 처리가 전혀 효용성이 없다.

**테이블 랜덤 액세스가 많아서 성능이 느린 경우 고려할 방안**

- 인덱스 컬럼 추가
    - 가장 우선해서 고려해야 한다.
- IOT
    - 가장 효과적이지만 테이블 구조 변경에 대한 부담과 IOT 자체의 부작용이 있다.
- 인덱스 순으로 정렬되도록 테이블 재생성
    - 클러스터링 팩터가 좋아져서 랜덤 액세스를 상당히 줄일 수 있다.

**인덱스에 컬럼을 추가 했을 때 현상**

- 인덱스 사이즈 증가
- 리프 블록 수 증가
- 인덱스 높이 증가
- 스캔 과정에 읽는 블록 I/O 증가 ⇒ 스캔 효율 감소
- 선두 컬럼의 NDV가 적으면 클러스터링 팩터가 나빠지고, NDV가 많더라도 클러스터링 팩터가 좋아지진 않는다.

**배치 I/O**

읽는 블록맞다 건건히 I/O을 발생시키는 비효율을 줄이기 위해 디스크 I/O를 모아놨다가 한번에 처리한다.