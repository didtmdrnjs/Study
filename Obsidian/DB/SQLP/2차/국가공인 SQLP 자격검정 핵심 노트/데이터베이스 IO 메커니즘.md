### 블록 단위 I/O

모든 DBMS에서 I/O는 블록 단위로 이루어 진다.

블록 단위 I/O는 버퍼캐시와 데이터파일 I/O 모두에 적용된다.

- 데이터파일에서 DB 버퍼캐시로 블록을 적재할 때
- 데이터파일에서 블록을 직접 읽고 쓸 때
- 버퍼캐시에서 블록을 읽고 쓸 때
- 버퍼캐시에서 변경된 블록을 데이터파일에 쓸 때

### 버퍼캐시 탐색 메커니즘

Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.

아래 오퍼레이션은 모두 버퍼캐시 탐색 과정을 거친다.

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 블록을 Full Scan 할 때

### 버퍼캐시 히트율

${BCHR = (1 - (물리적 I/O) / (논리적 I/O)) \times 100}$

- 물리적 I/O : disk
- 논리적 I/O : query + current

### LRU 알고리즘

모든 DBMS는 사용 빈도가 높은 데이터 블록들이 버퍼캐시에 오래 남아있도록 하기 위해 LRU 알고리즘을 사용한다.

모든 버퍼 블록 헤더를 LRU 체인에 연결해서 사용빈도에 따라 수시로 위치를 옮기다가, Free 버퍼가 필요해지면, 액세스 빈도가 낮은 데이터 블록들을 우선하여 밀어낸다.

### 시퀀셜 액세스 vs 랜덤 액세스

- 시퀀셜 액세스
    - 논리적 또는 물리적으로 연결된 순서를 따라 차례대로 블록을 읽어나가는 방식
    - 인덱스와 테이블을 스캔할 때 사용한다.
- 랜덤 액세스
    - 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
    - 인덱스 ROWID로 테이블 블록을 액세스할 때 사용한다.

### Single Block I/O

인덱스를 이용할 떄는 기본적으로 인덱스와 테이블 모두 Single Block I/O를 사용한다.

인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다.

Single Block I/O 대상 오퍼레이션

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

### Multiblock I/O

캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call을 할 때 디스크 상에 그 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능

db_file_multiblock_read_count 파라미터에 의해 결정된다.

인접한 블록이란 같은 익스텐트에 속한 블록을 의미하며, Multiblock I/O 방식은 익스텐트 경계를 넘지 못 한다.