### 대기 이벤트

프로세스가 공유 메모리의 버퍼캐시, 라이브러리 캐시에서 정보를 읽으려면 래치를 반드시 획득해야하는데, 래치를 획득하는 과정에서 경합이 발생하면 대기 이벤트가 나타나지만, 그렇지 않으면 대기 이벤트가 나타나지 않는다.

대기 이벤트는 프로세스가 CPU를 OS에 반환하고 수면(Sleep) 상태로 진입하는 원인을 기록하기 위해 개발 되었다.

프로세스가 CPU를 OS에 반환하고 수면 상태로 진입하는 원인

- 프로세스가 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용 중일 때
- 다른 프로세스에게 작업을 요청하고 해당 작업이 완료되기를 기다릴 때
- 프로세스가 할 일이 없을 때

대기 이벤트가 나타나는 대표적인 예시

- SGA 공유 메모리에서 특정 자원을 액세스하려고 래치를 획득하는 과정에 다른 프로세스와 경합이 발생
- 디스크로부터 블록 I/O를 요청
- 클라이언트로부터 다음 작업 요청이 오기를 기다림

대기 이벤트 종류 예시

- latch: shared pool
    - Shared Pool에서 특정 오브젝트 정보 또는 SQL 커서를 위한 Free Chunk를 할당 받으려 할 때 shared pool 래치를 할당받아야 한다.
    - shared pool 래치를 할당받는 과정에 발생하는 경합과 관련이 있으며, 하드 파싱을 동시에 심하게 일으킬 때 주로 나타난다.
- library cache lock
    - library cache lock과 library cache pin은 주로 SQL 수행 도중 DDL을 수행할 때 나타난다.
- free buffer waits
    - 서버 프로세스가 버퍼 캐시에서 Free Buffer를 찾지 못해 DBWR에게 공간을 확보해 달라고 신호를 보낸 후 대기할 때 나타난다.
- log file sync
    - 커밋 명령을 전송받은 서버 프로세스가 LGWR에게 로그 버퍼를 로그 파일에 기록해 달라고 신호를 보낸 후 대기할 때 나타난다.

대기 이벤트를 기반으로 세션 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 문제를 해결하는 방법, 과정을 대기 이벤트 기반 또는 응답 시간 분석(Response Time Analysis) 성능관리 방법론이라고 한다.

Response Time Analysis 성능관리 방법론은 세션 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 문제를 해결하는 방법과 과정을 다루며, 데이터베이스 서버의 응답 시간을 아래와 같이 정의한다.

Response Time

= Service Time + Wait Time

= CPU Time + Queue Time

여기서 Service Time, CPU Time은 프로세스가 정상적으로 동작하며 일을 수행한 시간을 의미하고, Wait Time, Queue Time은 CPU를 OS에 반환하고 수면 상태에서 대기한 시간을 의미한다.

**AWR**

오라클이 전통적으로 사용하던 Ratio 기반 성능 분석 방법론에 응답 시간 분석 방법론을 더해 Statspack을 개발하였고, 이를 확장 및 업그레이드 해서 만든 것이 AWR이다.

AWR 보고서를 활용해 성능 이슈를 해결하려면 peak 시간대 또는 장애 발생 시점을 전후해 가능한 짧은 스냅샷 구간을 선택해야 한다. 특정 시점에 큰 부하가 발생해도 하루나 일주일로 보고서를 보면 평균 수치로 보이기 때문이다.

사용자 인터뷰를 통해 성능 저하가 일어난 시간대를 파악하거나 sar, topas, vmstat, osstat 등 OS 모니터링 도구를 이용해 CPU, 메모리, I/O 사용량 정보를 수집하고 이를 통해 peak 시간대를 파악할 수 있다.

과거에는 SQL로 딕셔너리를 조회새서 성능 정보를 수집했기 때문에 이것 자체가 시스템에 부하를 주엇고, 따라서 스냅샷 주기를 짧게 설정하기 곤란했다.

반면, AWR은 뷰를 조회하지 않고 DMA 방식으로 SGA 공유 메모리를 직접 액세스해서 성능 정보를 수집하기 때문에 좀 더 빠르게 정보를 수집할 수 있다.

부하가 적기 때문에 Statpack보다 더 자주 더 많은 정보를 수집할 수 있게 되었다.

AWR 보고서에 출력되는 항목들은 dba_hist_로 시작하는 각종 뷰를 이용해 사용자가 직접 조회할 수도 있다.

버전마다 조금씩 다르지만 AWR 보고서 맨 앞쪽의 노고서 요약에서 다음 내용을 포함한다.

- 캐시 크기
- 부하 프로파일
- 인스턴스 효율성
- 최상위 대기 이벤트
- Shared Pool 통계
- IO 프로파일
- 메모리 통계

인스턴스 효율성 항목

- Buffer Nowait %
    - 버퍼 블록을 읽으려 할 때 buffer busy waits 대기 없이 곧바로 읽기에 성공한 비율
- Redo NoWait %
    - Redo 로그를 기록할 공간을 요청하지 않고 곧바로 Redo 엔트리를 기록한 비율
- Buffer Hit %
    - 디스크 읽기를 수반하기 않고 버퍼 캐시에서 블록 찾기에 성공한 비율
- Latch Hit %
    - 래치 경합없이 첫 번째 시도에서 곧바로 래치를 획득한 비율
- Library Hit %
    - Get 히트율과 Pin 히트율로 나눌 수 있다.
    - Pin 히트율
        - 라이브러리 캐시에 이미 적재된 SQL 커서를 실행하거나 오브젝트 정보를 읽으려 할 때 해당 커서 또는 오브젝트가 힙 영역에서 찾아진다면 히트에 성공한 것이다.
- Soft Parse %
    - 실행계획이 라이브러리 캐시에서 찾아져 하드 파싱을 일으키지 않고 SQL을 수행한 비율
- Execute to Parse %
    - Parse Call 없이 곧바로 SQL을 수행한 비율
- Parse CPU to Parse Elapsd %
    - 파싱 총 소요 시간 중 CPU time이 차지한 비율
- Non-Parse CPU %
    - SQL을 수행하면서 사용한 전체 CPU time 중 파싱 이외의 작업이 차지한 비율
- In-memory Sort %
    - 전체 소트 수행횟수에 In-memory Sort 방식으로 수행한 비율

**ASH(Active Session History)**

시스템에 문제가 생겼을 때 Ratio 기반 분석 방법이나, 대기 이벤트 기반 분석 방법론으로 원인을 찾아 문제를 해결하려면 많은 시간이 걸린다.

- 원인은 금방 알 수 있으나, 실제 문제를 해결하려면 구체적으로 어떤 프로그램, 어떤 세세ㅕㄴ에서 성능 문제를 야기했는지를 확인해야 한다.

실시간 모니터링을 통해 빠르게 해결하려면 세션 레벨 성능 분석이 필요한데, 오라클이 제공하던 세션 레벨 동적 뷰만으로는 한계가 많았다.

- 가장 상세한 세션 레벨 분석이 가능하지만, 시스템 부하가 크고, 파일 단위로 정보가 수집되기 때문에 통계적 접근이 어려우며, 분석을 완료하기까지 시간이 오래 걸린다.
- 이를 해결하기 위해 오라클은 ASH 기능을 도입했다.

ASH 기능은 현재 접속해서 활동 중인 인 세션 정보를 1초에 한 번씩 샘플링해서 ASH 버퍼에 저장한다. SGA Shared Pool에서 CPU 당 2MB의 버퍼를 할당받아 세션 정보를 기록하며, 1시간 혹은 버퍼의 2/3가 찰 때마다 디스크에 기록한다.

즉, AWR에 저장하는 것이다.

ASH에 저장된 세션 히스토리 정보는 v$active_session_history 뷰를 통해 조회할 수 있다. ASH 기증을 이용해 현재 뿐만 아니라 과거 시점에 발생한 장애 및 성능 저하 원인까지 세션 레벨 별로 분석할 수 있게 도와준다.

AWR에 옮겨진 세션 히스토리 정보는 dba_hist_active_sess_history 뷰를 통해 조회할 수 있다.

대기 이벤트가 많이 일어나는 원인을 찾기 위한 동적 성능 뷰

- v$session_wait
    - 대기 이벤트를 가장 많이 발생시키는 세션 목록을 확인할 수 있다.
- v$active_session_history
    - 문제의 세션들이 어떤 SQL을 수행하고 있는지 확인할 수 있다.
- v$sql
    - 문제 SQL의 전체 문장과 수행 통계(실행횟수, 평균 소요시간, 평균 블록 I/O 등)을 확인할 수 있다.