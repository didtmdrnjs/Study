### 오라클 Lock

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.

래치는 SGA에 공유된 각종 자료구조를 보호하기 위해서, 버퍼 Lock은 버퍼 블록에 대한 액세스를 직렬화하기 위해서, 라이브러리 캐시 Lock과 Pin은 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해서 사용된다.

하지만 이 중 애플리케이션 측면에서 가장 중요하게 다루어야 할 Lock은 무엇보다 DML Lock이다.

DML Lock은 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해 준다.

DML Lock은 데이블 Lock과 로우 Lock이 있다.

**DML 로우 Lock**

DML 로우 Lock은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다.

- 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 한다.

어떤 DBMS든 DML 로우 Lock에는 베타적 모드를 사용하므로 UPDATE 또는 DELETE를 진행 중인 로우를 다른 트랜잭션이 UPDATE 하거나 DELETE 할 수 없다.

INSERT에 대한 로우 Lock 경합은 Unique 인덱스가 있을 때만 발생한다.

즉, Unique 인덱스가 있는 상황에서 두 트랜잭션이 같은 값을 입력하려고 할 때, 블로킹이 발생한다.

- 블로킹이 발생하면, 후행 트랜잭션은 기다렸다가 선행 트랜잭션이 커밋하면 INSERT에 실패하고, 롤백하면 성공한다.
- 두 트랜잭션이 서로 다른 값을 입력하거나 Unique 인덱스가 아예 없으면, INSERT에 대한 로우 Lock 경합은 발생하지 않는다.

MVCC 모델을 사용하는 오라클은 SELECT 문에 로우 Lock을 사용하지 않는다.

- 오라클은 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 시작된 시점으로 되돌려서 읽는다.
- 변경이 진행 중인 로우를 읽을 때도 Lock이 풀릴 때까지 기다리지 않고 복사본을 만들어서 읽는다.
    - 따라서 SELECT 문에 Lock을 사용할 필요가 없다.

결국 오라클에서는 DML과 SELECT는 서로 진행을 방해하지 않는다.

참고로 MVCC 모델을 사용하지 않는 DBMS는 SELECT문에 공유 Lock을 사용한다.

- DML과 SELECT가 서로 진행을 방해할 수 있다.

DML 로우 Lock에 의한 성능 저하를 방지하려면, 온라인 트랜잭션을 처리하는 주간에 Lock을 필요 이상으로 오래 유지하지 않도록 커밋 시점을 조절해야 한다.

**DML 테이블 Lock**

오라클은 DML 로우 Lock을 설정하기 전에 테이블 Lock을 먼저 설정한다.

- TM Lock이라고도 한다.

Lock 모드 간 호환성

||NULL|RS|RX|S|SRX|X|
|---|---|---|---|---|---|---|
|NULL|o|o|o|o|o|o|
|RS|o|o|o|o|o||
|RX|o|o|o||||
|S|o|o||o|||
|SRX|o|o|||||
|X|o||||||

RS : row share

RX : row exclusive

S : share

SRX : share row exclusive

X : exclusive

테이블 Lock이라고 하면 테이블 전체에 Lock이 걸린다고 생각하기 쉽지만, 오라클이 말하는 테이블 Lock은 자신이 해당 테이블에서 현재 어떤 작업을 수행 중인지 알리는 일종의 푯말이다.

그리고 데이블 Lock의 모드에 따라서 후행 트랜잭션이 수행할 수 있는 작업의 범위가 결정된다.

대상 리소스가 사용 중일 때, 진로 선택

Lock을 얻고자 하는 리소스가 사용 중일 때, 프로세스는 아래 세 가지 방법 중 하나를 택한다.

보통은 내부적으로 진로가 결정돼 있지만 사용자가 선택할 수 있는 경우도 있는데, 사용자가 아래 세 가지 옵션을 모두 선택할 수 있는 문장이 바로 SELECT FOR UPDATE 문이다.

1. Lock이 해제 될 때까지 기다린다.
2. 일정 시간만 기다리다 포기한다.
3. 기다리지 않고 작업을 포기한다.

**Lock을 푸는 열쇠 커밋**

블로킹은 선행 트랜잭션이 설정한 Lock 떄문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춘 상태를 뜻하고, 교착 상태는 두 트랜잭션이 특정 리소스에 Lock을 설정한 상태에서 맞은편 트랜잭션이 Lock을 설정한 리소스에 또 Lock을 설정하려고 진행하는 상황을 말한다. 교착 상태가 발생하면 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없다.

- 오라클에서 교착 상태가 발생하면, 이를 먼저 인지한 트랜잭션이 문장 수준 롤백을 진행한 후 아래의 에러 메세지를 던진다.
    
    ```sql
    ORA-00060: deadlock detected while waiting for resource
    ```
    

이제 여기서 교착 상태는 해결되었지만, 블로킹 상태에 놓이게 되는데, 이 메세지를 받은 트랜잭션은 커밋 또는 롤백을 결정해야 한다.

- 만약 이에 대한 예외처리를 하지 않는다면 대기 상태를 지속하게 되므로 주의가 필요하다.

아래 옵션을 사용해 네 가지 커밋 명령을 사용할 수 있다.

- WAIT : LGWR가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때까지 기다린다.
- NOWAIT : LGWR의 완료 메시지를 기다리지 않고 바로 다음 트랜잭션을 진행한다.
- IMMEDIATE : 커밋 명령을 받을 때마다 LGWR가 로그 버퍼를 파일에 기록한다.
- BATCH : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리한다.

```sql
COMMIT WRITE IMMEDIATE WAIT;
COMMIT WRITE IMMEDIATE NOWAIT;
COMMIT WRITE BATCH WAIT;
COMMIT WRITE BATCH NOWAIT;
```

### 트랜잭션 동시성 제어

동시성 제어는 비관적 동시성 제어와 낙관적 동시성제어로 나뉜다.

- 비관적 동시성 제어(Pessimistic Concurrency Control)
    
    - 사용자들이 같은 데이터를 동시에 수정할 것으로 가정한다.
    - 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신 처리가 완료될 때까지 이를 유지한다.
    - Lock은 첫 번째 사용자가 트랜잭션을 완료하기 전까지 다른 사용자들이 같은 데이터를 수정할 수 없게 만들기 때문에 비관성 동시성 제어를 잘못 사용하면 동시성이 나빠진다.
    - SELECT FOR UPDATE를 사용하면 고객 레코드에 Lock을 설정하므로 데이터가 잘못 갱신되는 문제를 방지할 수 있다.
        - SELECT FOR UPDATE에 WAIT 또는 NOWAIT 옵션을 옵션을 함께 사용하면 Lock을 얻기 위해 무한정 기다리지 않아도 된다.
    
    **큐 테이블 동시성 제어**
    
    skip locked 옵션을 사용하면, Lock이 걸린 레코드는 생략하고 다음 레코드는 생략하고 다음 레코드를 계속 읽도록 구현할 수 있다.
    
- 낙관적 동시성 제어(Optimistic Concurrency Control)
    
    - 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정한다.
    - 데이터를 읽을 때 Lock을 설정하지 않는다.
    - 데이터를 수정하고자 할 때는 앞에서 읽은 데이터가 다른 사용자에 의해 변경되었는지 반드시 검사해야 한다.
    - 최종변경일시를 관리하는 컬럼이 있다면, 이를 조건절에 넣어 간단히 해당 레코드의 갱신 여부를 판단할 수 있다.

### 채번 방식에 따른 INSERT 성능 비교

INSERT, UPDATE, DELETE, MERGE 중 가장 중요하고 튜닝 요소가 많은 것은 INSERT이다.

채번 방식에 따른 성능 차이가 매우 크기 때문이다.

신규 데이터를 입력하면 PK 중복을 방지하기 위한 채번이 선행되어야 한다.

**채번 방식**

- 채번 테이블
- 시퀀스 오브젝트
- MAX + 1 조회

**채번 테이블**

각 테이블 식별자의 단일 컬럼 일련버호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식이다.

채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 사용해 입력하는데 사용한다.

이 방식은 채번 레코드를 변경하는 과정에서 자연스럽게 액세스 직렬화가 이루어지므로 두 트랜잭션이 중복 값을 채번할 가능성을 원천적으로 방지해 준다.

이 방식의 장점은 다음과 같다.

- 범용성이 좋다.
- INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 되므로 채번 함수만 잘 정의하면 편리하게 사용할 수 있다.
- INSERT 과정에 결번을 방지할 수 있다.
- PK가 복합 컬럼일 때도 사용할 수 있다.

가장 큰 단점은 다른 채번 방식에 비해 성능이 안 좋다.

- 채번 레코드를 변경하기 위한 로우 Lock 경합 때문이다.
- 로우 Lock은 기본적으로 대상 테이블에 INSERT를 마치고 커밋 또는 롤백할 때까지 지속된다.
    - 동시 INSERT가 아주 많으면 채번 레코드 뿐만 아니라 채번 테이블 블록 자체에도 경합이 발생한다.
    - PK가 복합 컬럼인 경우 Lock 경합이 줄어들지만, 구분 속성 레코드 수가 소수일 때만 이 방식을 사용하므로 Lock 경합이 발생할 가능성은 다른 채번 방식에 비해 여전히 높다.

**시퀀스 오브젝트**

가장 큰 장점은 성능이 빠르다는 것이다.

채번 테이블과 마찬가지로 INSERT 과정에 중복 레코드 발생에 대비한 예외처리에 크게 신경 쓰지 않아도 된다.

테이블 별로 시퀀스 오브젝트를 생성하고 관리하는 부담은 있지만, 개발팀 입장에서는 사용하기 매우 편리하다.

가장 큰 장점이 성능이지만 성능 이슈가 없는 것은 아니다. 시퀀스 채번 과정에 발생하는 Lock 때문이다.

- 시퀀스 오브젝트는 오라클 내부에서 관리하는 채번 테이블 이다.
- 시퀀스 오브젝트도 결국 테이블 이므로 값을 읽고 변경하는 과정에서 Lock 메커니즘이 작동한다.
- 캐시 사이즈를 적절히 설정하면 가장 빠른 성능을 내며, 시퀀스에는 자율 트랜잭션 기능도 기본적으로 구현되어 있다.

**시퀀스 Lock**

오라클이 시퀀스 오브젝트에 사용하는 Lock은 세 가지가 있다.

- 로우 캐시 Lock
    - 매번 디스크에서 딕셔너리 정보를 읽고 쓰면 성능이 매우 느리므로 오라클은 로우 캐시를 사용한다.
    - 로우 캐시는 공유 캐시의 구성요소이므로 정보를 읽고 쓸 때 액세스를 직렬화 해야하는데 이를 위해 사용하는 Lock이 로우 캐시 Lock이다.
- 시퀀스 캐시 Lock
    - 시퀀스 캐시도 공유 캐시에 위치한다. 따라서 시퀀스 캐시에서 값을 얻을 때도 액세스 직렬화가 필요하며, 이를 SQ Lock이라고 한다.
- SV Lock
- 시퀀스 캐시는 한 인스턴스 내에서 공유되는데, nextval을 호출하는 순서대로 값을 제공하므로 인스턴스 내에서는 번호 순서를 보장한다.
- RAC 환경에서는 그렇지 않은데, 이 때 SV Lock을 통해 시퀀스 캐시에 대한 액세스를 직렬화한다.

시퀀스의 단점은 PK가 단일 컬럼일 때만 사용가능하다는 것이다.

또 다른 단점으로는 결번이 생길 수 있다는 것이다.

- 시퀀스 채번 이후에 트랜잭션을 롤백하는 경우에 발생할 수 있다.
- CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우에도 발생할 수 있다.

**MAX + 1 조회**

대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT하는 방식이다.

**이 방식의 장점**

- 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 없다.
- 동시 트랜잭션에 의한 충돌이 많지 않으면, 성능이 매우 빠르다.
- PK가 복합 컬럼인 경우에도 사용할 수 있다.
    - 값의 수가 많을 수록 성능이 좋아진다.
    - Lock 경합이 줄고 재실행 횟수도 줄기 때문이다.

**단점**

- 레코드 중복에 대비한 세밀한 예외처리가 필요하다.
- 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있다.
    - 레코드 중복에 의한 로우 Lock 경합 때문이다.

**Lock 경합 요소를 고려한 채번 방식 선택 기준**

- 다중 트랜잭션에 의한 동시 채번이 많지 않으면, 세 가지 방식 중 어느 것을 사용해도 크게 상관 없다. 하지만 채번 테이블이나 시퀀스 오브젝트 관리 부담을 고려하면, 가급적 MAX + 1 방식을 사용하는 것이 좋다.
- 다중 트랜잭션에 의한 동시 채번이 많고 PK가 단일 컬럼 일련번호라면, 시퀀스 방식이 가장 좋다.
- 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 많으면, 중복에 의한 로우 Lock 경합 및 재실행 가능성이 낮다. 그렇다면 시퀀스 보다 MAX + 1 방식이 구조적으로 좋다.
- 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 적으면, MAX + 1 방식은 성능에 문제가 생길 수 있다. 그럴 때 순환 옵션을 가진 시퀀스 오브젝트 활용을 고려할 수 있다.