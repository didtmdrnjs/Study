### 인덱스 설계가 어려운 이유

SQL 각각에 최적화된 인덱스를 마음껏 생성할 수 있다면 SQL튜닝과 인덱스 설계만큼 쉬운 일도 없다.

- 몇 가지 공식만 알면 되기 때문이다.
- 하지만 그렇게 인덱스를 생성하다 보면 테이블마다 인덱스가 수십 개씩 달리게 되고, 관리비용 뿐만 아니라 시스템 부하를 증가시키는 요인이 된다.

**인덱스가 많으면 생기는 문제**

- DML 성능 저하(TPS 저하)
- 데이터베이스 사이즈 증가(디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

### 가장 중요한 두 가지 선택 기준

인덱스 스캔 방식에 여러 가지가 있지만, 가장 정상적이고 일반적인 방식은 Index Range Scan이다.

- 이를 위해서는 선두 컬럼을 조건절에 반드시 사용해야한다.
    - 첫 번째 기준은 조건절에 항상 사용하거나 자주 사용하는 컬럼
- 두 번째 기준은 선정한 컬럼 중 ‘=’조건으로 자주 조회하는 컬럼을 앞쪽에 두어야한다.

### 스캔 효율성 이외의 판단 기준

위의 두 기준이 인덱스를 설계할 때 일반적으로 사용하는 기본 공식임은 틀림없다. 하지만 인덱스 설계가 그렇게 간단하지는 않다. 공식을 모를 때보다 오히러 인덱스의 개수가 늘어나기도 하기 때문이다.

위의 공식은 인덱스 스캔 효율성이 판단 기준이었다.

그 외는 다음과 같다.

- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터 양
- DML 부하(기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용

이 중 가장 중요한 것을 뽑으라면 수행 빈도일 것이다.

- 자주 수행되지 않는 것은 약간의 비효율이 있어도 큰 문제가 아니지만, 자주 사용한다면 위의 공식을 써서 최적화를 해줘야한다.

데이터 양도 설계할 떄 중요한 판단 기준이다.

- 데이터 양이 적다면 굳이 인덱스를 만들 필요가 없다.
- 반대로 인덱스를 많이 만들어도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제될 것이 없다.

### 공식을 초월한 전략적 설계

구성해야할 인덱스가 많을 때 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준에서 그쳐야 한다.

- 업무 상황을 이해하고 나름의 판단 기준을 가지고 결정을 내려야한다.

이렇게 인덱스 개수를 최소화 하면 사용빈도가 높거나 중요한 액세스 경로가 새로 도출되었을 때 최적의 인덱스를 추가할 여유도 생긴다.

### 소트 연산을 생략하기 위한 컬럼 추가

인덱스는 항상 정렬 되어 있으므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해준다.

- 따라서 조건절에 없는 컬럼이라도 소트 연산 생략을 위해 인덱스 구성에 포함 시킴으로써 성능 개선을 도모할 수 있다.
- ‘=’이 아닌 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 한다.

I/O를 최소화하면서도 소트 연산을 생략하는 공식

- ‘=’ 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- ‘=’ 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

소트 연산이 생략되려면 IN 조건절이 IN-List Iterator로 풀리면 안된다.

### 결합 인덱스 선택도

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준이다.

- 선택도란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다.
- 인덱스 선택도는 인덱스 컬럼을 모두 ‘=’로 조회할 때 평균적으로 선택되는 비율을 의미하며, 선택도가 높은 인덱스는 생성해봐야 효용가치가 별로 없다.
    - 테이블 액세스가 많이 발생하기 때문이다.

### 중복 인덱스 제거

인덱스가 다른 인덱스를 완전히 포함하고 있는 것을 완전 중복이라고 하며, 중복되는 인덱스는 삭제해도 된다.

- 인덱스 구성이 다른 것 같아도 겹치는 컬럼의 평균 카디널리티가 낮다면 사실상 중복이다. 이것을 불완전 중복이라한다.