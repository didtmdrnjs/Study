### 서브 쿼리 변환이 필요한 이유

옵티마이저는 비용을 평가하고 실행 계획을 생성하기 전에 사용자로 부터 받은 SQL을 최적화에 유리한 형태로 변환하는 작업인 쿼리 변환부터 진행한다.

- 이 때문에 옵티마이저 엔진은 점점 무거워지고 최적화에 소요되는 시간도 점점 늘고 있다.

서브 쿼리는 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록(Query Block)을 말한다.

오라클은 아래 세 가지로 분류한다.

- 인라인 뷰(Inline View) : FROM 절에 사용한 서브쿼리
- 중첩된 서브쿼리(Nested Subquery) : 결과 집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리
    - 특히, 서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 상관관계 서브쿼리라고 한다.
- 스칼라 서브쿼리(Scalar Subquery) : 한 레코드 당 정확히 하나의 값을 반환하는 서브쿼리
    - 주로 SELECT-LIST에서 사용하며, 컬럼이 올 수 있는 대부분 위치에 올 수 있다.

### 서브쿼리 조인

**필터 오퍼레이션**

서브쿼리를 풀어내지 말고 그대로 수행하게 하려면 서브쿼리에 no_unnest 힌트를 사용하면 된다.

- 이렇게 되면 서브쿼리를 필터 방식으로 처리한다.
    
- Filter 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같다.
    
    ```sql
    Execution Plan
    --------------------------------------
    0    SELECT STATEMENT Optimizer=ALL_ROWS
    1 0    FILTER
    2 1      TABLE ACCESS (FULL) OF 테이블1 (TABLE)
    3 2        INDEX (RANGE SCAN) OF 인덱스1 (INDEX)
    4 1      INDEX (RANGE SCAN) OF 인덱스2 (INDEX)
    ```
    
    따라서 FILTER를 NESTED LOOPS로 치환하고 처리 루틴을 해석하면 된다.
    
    NL 조인 처럼 부분 범위 처리도 가능하다.
    
    **차이점**
    
    - 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공한 순간 진행을 멈추고 메인쿼리의 다름 로우를 처리한다.
    - 필터는 캐싱기능을 갖는다.
        - 서브쿼리 입력 값에 따른 반환 값을 캐싱한다.
        - 이 기능 때문에 서브쿼리를 수행하기 전에 항상 캐시부터 확인한다.
        - 일반 NL 조인과 달리 메인쿼리에 종속되므로 조인 순서가 고정된다.

**서브쿼리 Unnesting**

그냥 두어도 옵티마이저는 대개 Unnesting을 선택하지만 명시적으로 unnest 힌트를 사용한다.

서브쿼리 Flattening이라고도 한다.

서브쿼리를 그대로 두면 필터 방식을 사용할 수 밖에 없지만 Unnesting 하고 나면 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있다.

nl_sj 힌트를 통해 NL 세미 조인을 사용할 수 있으며, NL 세미 조인은 조인 프로세스는 NL 조인과 같지만 조인에 성공하는 순간 진행을 멈추고 메인쿼리의 다음 로우를 처리한다는 점만 다르다.

Unnesting된 서브쿼리는 메인 쿼리 집합보다 먼저 처리 될 수 있다.

```sql
// 메인쿼리 힌트
/*+ leading(테이블2@subq) use_nl(테이블1) */

// 서브쿼리 힌트
/*+ qb_name(subq) unnest */
```

**서브쿼리 Pushing**

Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대개 실행계획 상에서 맨 마지막 단계에서 처리된다.

서브쿼리 필터링을 먼저 처리하기 위해서는 push_subq 힌트를 사용한다.

- Pushing 서브쿼리를 사용하기 위해서는 Unnesting이 사용되면 안되기 때문에 no_unnest 힌트를 같이 사용해야 한다.

반대로 서브쿼리 필터링을 나중에 처리하기 위해서는 no_unnest 힌트와 no_push_subq 힌트를 같이 사용하면 된다.

### 뷰(View)와 조인

최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰(View) 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.

뷰 머징을 유도하려면 merge 힌트를 사용하면 된다.

- 인라인 뷰와 메인쿼리의 조건절을 먼저 다 처리한 후 조인

**조인 조건 Pushdown**

조인 조건을 전부 인라인 뷰 안으로 넣는 것이다.

push_pred 힌트를 사용하며 no_merge 힌트를 함께 사용한다.

부분범위 처리가 가능하다.

### 스칼라 서브쿼리 조인

**스칼라 서브쿼리의 특징**

- 메인쿼리 레코드마다 정확히 하나의 값만 반환한다.
- 컨텍스트 스위칭 없이 메인쿼리와 서브쿼리를 한 몸체처럼 실행한다.
- 조인에 실패한 스칼라 서브쿼리는 NULL을 출력한다.
- 처리 과정에서 캐싱 작용이 일어난다.

**스칼라 서브쿼리 캐싱 효과**

스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하고자 입력 값과 출력 값을 내부 캐시에 저장해 둔다.

- 쿼리 단위로 캐싱이 이루어지며, 쿼리를 시작할 때 PGA 메모리에 공간을 할당한다.
- 쿼리를 마치는 순간 공간을 반환한다.

**스칼라 서브쿼리 캐싱 부작용**

- 스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수 여서 해시 충돌 가능성이 작을 때 효과가 있다.
    - 반대의 경우라면 캐시를 매번 확인하는 비용 때문에 오히려 성능이 나빠지고 CPU 사용률만 높게 만들고 메모리도 더 사용한다.
- 캐시에 담을 수 없을 만큼 컬럼이 많이 존재한다면 불필요한 자원만 낭비하게 된다.
    - 매번 캐시를 탐색하지만 거의 데이터를 찾지 못하기 때문이다.
- 메인쿼리 집합이 매우 작은 경우 캐싱이 성능에 도움을 주지 못한다.
    - 메인쿼리 집합이 작으면 캐시 재사용성이 낮기 때문이다.

**두 개 이상의 값 반환**

인라인 뷰로 구하는 값들을 모두 문자열로 모두 결합하고, 바깥쪽 쿼리에서 substr 함수로 다시 분리한다.

```sql
select substr(c, 1, 10), substr(c, 11, 10), substr(c, 21)
from (select lpad(avg(c1), 10) || lpad(min(c2), 10) || lpad(max(c3), 10)
			from t) t1;
```

**스칼라 서브쿼리 Unnesting**

스칼라 서브쿼리는 NL 방식으로 조인하는데, 다른 조인 방식을 사용하기 위해 일반 조인문으로 변환해야 더 효율적인 상황이 있다.

- 오라클 12c부터 스칼라 서브쿼리도 Unnesting이 가능해졌는데, 옵티마이저가 사용자 대신 자동으로 쿼리를 변환해 준다.
- no_unnest를 통해서 스칼라 서브쿼리 Unnesting으로 인해 일부 쿼리에 생긴 문제를 해결할 수 있다.