### 인덱스를 사용한다는 것

인덱스를 정상적으로 사용하려면 인덱스 컬럼(정확히는 선두 컬럼)을 가공하지 않아야 한다.

인덱스를 정상적으로 사용한다는 말은 리프 블록에서 스캔 시작점을 찾아 거기서 부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉, 리프 블록을 일부만 스캔하는 Index Range Scan을 의미한다.

인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만 스캔의 시작점을 찾을 수도 없고, 중간에 멈출 수도 없기 때문에 리프 블록 전체를 스캔해야한다. 즉, 인덱스 전체를 스캔하는 Index Full Scan 방식으로 작동한다.

### 인덱스를 Range Scan 할 수 없는 이유

인덱스에는 가공되지 않는 값이 저장되어있는데, 가공된 값을 기준으로 검색을 하면 스캔 시작점을 찾을 수 없고, 스캔 끝지점도 찾을 수 없다.

**OR Expansion**

아래와 같이 쿼리를 작성하면 고객명, 전화번호 인덱스 각각에 대해 Index Range Scan이 가능하다.

```sql
select * 
from 고객
where 고객명 = :cust_nm
union all
select *
from 고객
where 전화번호 = :tel_no
and (고객명 <> :cust_nm or 고객명 is null)
```

OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데 이를 OR Expansion이라고 한다.

use_concat 힌트를 사용하여 OR Expansion을 유도할 수 있다.

다음과 같은 조건절에서는 인덱스를 정상적으로 사용할 수 없다.

```sql
where substr(생년월일, 5, 2) - '05'

where nvl(주문수량, 0) < 100

where 업체명 like '%대한%'

where (전화번호 = :tel_no or 고객명 = : cust_nm)

where 전화번호 in (:tel_no1, :tel_no2)
```

단, OR 또는 IN 조건절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan으로 처리되기도 한다.

### 더 중요한 인덱스 사용조건

Index Range Scan를 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 것이다. 첫 번째 컬럼이 가장 정렬의 우선순위가 높기 때문이다.

### 인덱스를 이용한 소트 연산 생략

인덱스를 Range Scan 할 수 있는 이유는 데이터가 정렬되어있기 때문이다.

SQL은 이렇게 정렬되어있다는 성질을 이용해 SQL에 ORDER BY 절이 있더라도 정렬 연산을 수행하지 않는다.

### ORDER BY 절에서 컬럼 가공

‘인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다’에서 인덱스 컬럼은 대개 조건절에서 사용하는 컬럼을 말한다.

그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

```sql
select *
from (
	select TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
	from 주문 A
	where A.주문일자 = :dt
	and A.주문번호 > NVL(:next_ord_no, 0)
	order by 주문번호(=> A.주문번호로 바꿔줘야 한다)
)
where ROWNUM <= 30;
// 인덱스 [주문일자 + 주문번호]
// 주문 번호가 TO_CHAR로 가공된 값이기 때문에 정렬 연산이 수행됨
```

### SELECT-LIST에서 컬럼 가공

인덱스를 구성하는 방식에 따라서 MIN, MAX를 구할 때에도 정렬연산을 따로 수행하지 않는다.

조건의 가장 왼쪽/오른쪽이 최소값/최대값이기 때문이다.

그런데 만약 아래와 같이 쿼리를 짜게 되면 정렬연산을 수행할 수 없다.

인덱스에는 문자열 기준으로 정렬이 되어있지만, 이를 숫자값으로 변경한 것으로 쿼리를 했기 때문이다.

```sql
select NVL(MAX(TO_NUMBER(변경순번))), 0) (=> MAX(To_NUMBER(변경순번)) 부분을 TO_NUMBER(MAX(변경순번))으로 바꿔줘야 한다)
from 상태변경이력
where 장비번호 = 'C'
and 변경일자 = '20180316'
// 인덱스 [장비번호 + 변경일자 + 변경순번]
```

### 자동 형변환

각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다.

그럴 때 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS가 있는가 하면, 자동으로 형변환을 처리해주는 DBMS가 있다. 오라클은 여기서 후자에 속한다.

- 문자형과 숫자형이 만나면 문자형을 숫자형으로 바꾼다.
    - Like 연산자일 경우에는 숫자형이 문자형으로 바뀐다.
        
        - Like 연산자를 사용하는 경우
            
            Like 연산자를 조건 처리를 위해 사용하는 경우가 종종 있다.
            
            예를 들어 거래 조회 시 계좌번호를 사용자가 입력할 수도 있고, 안 할 수도 있다. 이 경우에는 두 개의 SQL이 필요하다.
            
            ```sql
            select * from 거래
            where 계좌번호 = :acnt_no
            and 거래일자 between :trd_dt1 and :trd_dt2
            
            select * from 거래
            where 거래일자 between :trd_dt1 and :trd_dt2
            ```
            
            하지만 여기서 Like를 사용해 SQL을 하나로 줄일 수 있다.
            
            ```sql
            select * from 거래
            where 계좌번호 LIKE :acnt_no || '%'
            and 거래일자 between :trd_dt1 and :trd_dt2
            
            // 계좌번호가 입력되지 않으면 :acnt_no에 NULL을 넣어 모든 계좌가 검색되도록
            ```
            
            하지만 인덱스 스캔 효율이 안 좋아진다.
            
            또 계좌번호 컬럼이 숫자형일 경우 자동형변환이 발생하기 때문 인덱스를 활용하지 못한다.
            
    - 문자형 컬럼이 숫자로 변환할 수 없는 문자열이 입력되면 쿼리 수행 도중 에러가 난다.
        
- 문자형과 날짜형이 만나면 문자형을 날짜형으로 바꾼다.
    - NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과집합이 틀려질 수 있다.
- 결과 오류가 생기는 경우
    - 오라클은 decode(a, b, c, d) 함수를 처리할 때 a = b면 c를 반환하고, 아니면 d를 반환한다. 이때 반환 값의 데이터 타입은 c에 의해 결정된다. 따라서 c가 문자형이고, d가 숫자형이면 d는 문자형으로 변환된다. 또 여기서 c가 null이면 varchar2로 취급되기 때문에 d를 문자열로 변환한다.