### 부분범위 처리

DBMS가 클라이언트에게 데이터를 전송할 때도 일정량씩 나누어 전송한다.

전체 결과집합중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로 부터 추가 Fetch Call을 받기 전까지 그대로 멈춰 서서 기다린다.

- OLTP 환경에서 대용량 데이터를 빠르게 핸들링할 수 있는 아주 중요한 원리가 바로 여기 있다.
    - DBMS가 데이터를 모두 읽어 한번에 전송하지 않고, 먼저 읽는 데이터부터 일정량을 전송하고 멈추기 때문이다.
    - 데이터를 전송하고 나면 서버 프로세스는 CPU를 OS에 반환하고 대기 큐에서 잠을 자고, 다음 Fetch Call을 받으면 대기 큐에서 나와 그 다음 데이터부터 일정량을 읽어서 전송하고 다시 잠을 잔다.
    - 이렇게 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 부분범위 처리라고 한다.

**정렬 조건이 있을 때 부분범위 처리**

DB 서버는 모든 데이터를 다 읽어 created 순으로 정렬을 마치고서야 클라이언트에게 데이터 전송을 시작할 수 있다.(전체범위 처리) Sort Area와 Temp 테이블 스페이스까지 이용해 데이터 정렬을 마치고 나면 그때 부터 일정량씩 나눠 클라이언트에게 데이터를 전송한다.

여기서 created 컬럼이 선두인 인덱스가 있으면 부분 범위 처리가 가능하다.

- 정렬된 상태이기 때문에 전체 데이터를 정렬하지 않고도 정렬된 상태의 결과집합을 바로 보낼 수 있기 때문이다.

**Array Size 조정을 통한 Fetch Call 최소화**

전송해야할 데이터량에 따라 Array Size를 조절해 줘야한다.

- 대량의 데이터를 받는 경우에는 가급적 Array Size를 크게 잡아야한다.
    - Fetch Call이 줄기 때문이다.
- 앞쪽만 읽고 멈추는 프로그램이면 Array Size를 작게하는 것이 유리하다.
    - 불필요한 데이터 전송을 막을 수 있기 때문이다.

### OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

OLTP는 Online Transaction Processing의 줄임말이다. 말 그대로 온라인 트랜잭션을 처리하는 시스템이다.

- 일반적으로 소량의 데이터를 다룬다.
- 항상 소량 데이터만 조회하는 것은 아니다.
    - 특정한 정렬 순서로 상위 일부 데이터만 확인하기 때문에 인덱스와 부분처리로 극적인 성능개선을 할 수 있다.

### 배치 I/O

인덱스 ROWID를 이용한 테이블 랜덤 액세스는 고비용 구조다. 인덱스를 이용해 대량 데이터를 조회하면, 디스크 I/O도 함께 증가하기 때문에 성능이 급격하게 나빠진다.

- 부분범위 처리 원리를 활용해서 상위 N개의 집합을 빠르게 출력하도록 구현할 수 있다면, 인덱스로 액세스할 전체 대상 레코드가 아무리 많아도 빠른 응답 속도를 낼 수 있다.

배치 I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능이다.

- 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 바로 읽는데, 이 기능을 쓰면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 일정량 쌓이면 한꺼번에 처리하는 것이다.

**데이터 정렬 이슈**

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다.

- 모두 버퍼 캐시에서 읽으면 인덱스 키 값 순으로 출력된다.
    
- 그게 아니면 인덱스 정렬 순서와 다를 수 있다.
    
- 해결방법
    
    - no_batch_table_access_by_rowid 힌트를 사용한다.
    - ORDER BY를 추가한다.