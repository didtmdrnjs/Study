### 소프트 파싱 vs 하드 파싱

SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 **라이브러리 캐시(Library Cache)**라 한다.

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다. 이 때 소프트 파싱과 하드 파싱은 다음과 같이 정의된다.

- 소프트 파싱 : SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
- 하드 파싱 : 캐시에서 찾지못해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것 → SQL은 일회성이기 때문에 자주 쓰는 SQL은 프로시저를 통해서 하드 파싱의 발생을 최소화 해야한다.

**SQL 최적화 과정이 하드한 이유**

- 고려 할 것이 많다.
    - 조인 순서, 조인 종류, 인덱스를 쓸지 테이블을 쓸지, 인덱스 스캔의 종류 등 다양한 경우의 수가 나온다.
- 옵티마이저가 사용하는 정보
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브적트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
    - 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
    - 옵티마이저 관련 파라미터
- 옵티마이저는 이 수 많은 경우의 수를 계산하고 판단하는 과정은 결코 가벼울 수가 없는데, 이렇게 어렵게 생성한 내부 프로시저를 한 번 쓰고 버린다면 엄청난 비효율이기 때문에 라이브러리 캐시가 필요하다.

### 바인드 변수의 중요성

**이름없는 SQL 문제**

- 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때 이름을 갖는다.
    - 컴파일한 상태로 딕셔너리에 저장된다.
    - 사용자가 삭제하지 않는한 영구적으로 보관된다.
    - 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.
- SQL은 이름이 따로 없기 때문에 전체 SQL 텍스트가 이름 역할을 한다.
    - 딕셔너리에 저장되지 않는다.
    - 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리에 적재함으로써 여러 사용자가 공유하면서 재사용한다.
    - 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재된다.
- IBM DB2같은 DBMS는 SQL을 영구 저장하고 있다.
- 오라클, SQL Server 같은 DBMS가 SQL을 영구저장하지 않는 이유
    - SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면, 그 순간 다른 객체가 생성된다.
    - SQL을 영구저장하게 되면 개발과정 중 발생한 일회성 SQL이나 무효화된 SQL까지 모두 저장하기 때문에 저장공간이 많이 필요하고, SQL을 찾는 속도도 느려지기 때문이다.

**공유 가능 SQL**

- 아래와 같은 로그인 모듈이 있다고 했을 때

```java
public void login(String login_id) throws Exception {
	String SQLStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id "'";
	Statement st = con.createStatement();
	ResultSet rs = st.executeQuery(SQLStme);
	if (rs.next()) {
		// do anything
	}
	rs.close();
	st.close();
}
```

- 100만명 정도 되는 사람이 동시에 시스템 접속을 하게 되는 경우
    
    - DBMS에 발생하는 부하는 대개 과도한 I/O가 원인인데, I/O가 거의 발생하지 않음에도 불구하고 CPU 사용률이 급격하게 증가한다.
    - 라이브러리 캐시에 발생하는 여러 종류의 경합 때문에 로그인이 제대로 처리되지 않는다.
    - 각 고객에 대해 동시다발적으로 발생하는 SQL 하드 파싱 때문이다.
- 로그인 프로그램을 이렇게 작성하면, 각 고객에 대해서 내부 프로시저를 하나씩 만들어서 라이브러리 캐시에 적재하는 셈이다.
    
- 여기서 생성되는 프로시저의 내부 처리는 모두 같기 떄문에 아래와 같이 로그인 ID를 파라미터로 받는 프로시저 하나를 공유하면서 재사용하는 것이 맞다.
    
    ```sql
    create procedure LOGIN(login_id in varchar2) {...}
    ```
    
- 이 처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다.
    
- 바인드 변수 덕문에 여러 프로시저를 생성하지 않고 하나의 프로시저를 공유하면서 재사용할 수 있다.