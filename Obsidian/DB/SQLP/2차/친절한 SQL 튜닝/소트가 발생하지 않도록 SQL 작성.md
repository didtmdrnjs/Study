### Union vs Union All

SQL에 Union을 사용하면 옵티마이저는 상단과 하단 두 집합 간 중복을 제거하려고 소트 작업을 수행한다. 반면, Union All은 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않는다.

- 따라서 될 수 있으면 Union All을 사용해야한다.
- Union All을 사용하려다 자칫 잘 못하면 결과 집합이 바뀔 수도 있다.

```sql
// 조건절에 다음과 같이 해 줄 수도 있다.
select *
from 결제
where 결제일자 = '20180316'
UNION ALL
select * 
from 결제
where 주문일자 = '20180316'
and 결제일자 <> '20180316'
// 결제일자가 null 허용 컬럼일 경우 다음과 같이 해야한다.
and (결제일자 <> '20180316' or 결제일자 is null)
```

### Exists 활용

중복 레코드를 제거할 목적으로 Distinct 연산자를 종종 사용하는데, 이 연산자를 사용하면 조건에 해당하는 데이터를 모두 읽어서 중복을 제거해야 한다. 부분 처리는 당연히 불가능하고, 모든 데이터를 읽는 과정에서 많은 I/O가 발생한다.

Exists 서브쿼리는 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 데이터를 모두 읽지 않는다.

Distinct, Minus 연산자를 사용한 쿼리는 대부분 Exists 서브쿼리로 변환 가능하다.

### 조인 방식 변경

인덱스 구조에서는 소트 연산을 생략할 수 있지만, 해시 조인에서 Sort Order By가 나타나는 경우가 있는데 이를 NL 조인으로 유도하게 되면 소트연산을 생략할 수 있다.

정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있다.