### ROWID는 물리적 주소? 논리적 주소?

SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면 인덱스를 스캔한 후에 반드시 테이블 액세스를 한다. 실행계획에서 TABLE ACCESS BY INDEX ROWID가 이 부분이다.

인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻는데 있다.

- ROWID를 물리적 주소라고 한다면 ROWID가 데이터 파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소로 구성되어있어서다.
    - 하지만 인덱스 ROWID는 물리적으로 직접 연결되어있지 않고, 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문에 논리적 주소에 가깝다.

### 메인 메모리 DB와 비교

메인 메모리 DB(MMDB)는 말 그대로 데이터를 모두 메로리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB라고 할 수 있다.

그런데 잘 튜닝된 OLTP성 데이터베이스 시스템이라면 버퍼캐시 히트율이 99% 이상이다.

- 디스크를 경유하지 않고 대부분 데이터를 메모리에서 읽는다는 것이다.
- 그렇지만 메인 메모리 DB만큼 빠르지 않고, 특히 대량의 데이터를 인덱스로 액세스할 때는 엄청난 차이가 난다.
    - 그 이유는 메인 메모리 DB의 구조에 있다.
    - 어떤 메인 메로리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다.
    - 이때 인덱스는 오라클 처럼 디스크 상의 주소가 아닌 메모리 상의 주소를 갖는다. 따라서 테이블에 액세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다.

### I/O 메커니즘 복습

I/O 성능을 높이려면 버퍼캐시를 활용해야한다.

그래서 블록을 읽을 때 디스크로 가기 전에 버퍼캐시 부터 찾아본다.

- DBA를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
    - 캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로 버퍼 헤더는 항상 같은 해시 체인에 연결되는 반면, 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱 되는데, 그 메모리 주소값을 버퍼 헤더가 가지고 있다.
    - 따라서 해싱 알고리즘으로 버퍼 해더를 찾고 거기서 얻은 포인터로 버퍼 블록을 찾아간다.

인덱스로 테이블 블록을 액세스할 떄는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고, 테이블을 Full Scan 할 때는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.

인덱스 ROWID는 디스크 상에서 테이블 레코드를 찾아가기 위한 논리적인 주소 정보다.

- ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼처 찾아보고 못 찾을 때만 디스크에서 블록을 읽는다.

설령 모든 데이터가 캐싱되어 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야한다. 동시 액세스가 심할 때는 캐시버퍼 체인 래치와 버퍼 Look에 대한 경합까지 발생하기 때문에 인덱스 ROWID를 활용한 테이블 액세스는 고비용 구조다.

### 인덱스 클러스터링 팩터

클러스터링 팩터(CF)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미하는데, CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 좋다.

클러스터링 팩터가 가장 좋은 상태이면 인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 100% 일치한다.

**인덱스 클러스터링 팩터 효과**

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다고 했는데 이는 테이블 액세스량에 비해 블록 I/O가 적게 발생함을 의미한다.

인덱스 ROWID로 테이블을 액세스할 때, 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지 시키는데, 이를 버퍼 Pinning이라고 한다.

- 이 상태에서 다음 인덱스 레코드를 읽었는데 직전과 같은 테이블 블록을 가리킨다면 래치 획득과 해시 체인 스캔 과정을 생략하고 바로 테이블 블록을 읽을 수 있다.
- 즉, 논리적 블록 I/O를 생략할 수 있다.

### 인덱스 손익분기점

인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다. 따라서 읽어야 하는

- 데이터가 일정량을 넘는 순간 테이블 전체를 스캔하는 것보다 오히려 느려지게된다.
- 여기서 Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 한다.

Table Full Scan은 성능이 일정하다. 1000만 건 중 한 건을 조회하든, 10만 건을 조회하든, 다 조회하든 차이가 거의 없다. 하지만 인덱스를 이용할 때는 성능이 크게 달라진다. 바로 테이블 랜덤 액세스 때문이다.

인덱스를 사용하는 것이 Table Full Scan 보다 느려지는 핵심적인 요인

- Table Full Scan은 시퀀셜 액세스지만, 인덱스 ROWID를 이용한 액세스는 랜덤 액세스이다.
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 액세스는 Single Block I/O다.

이러한 요인으로 인해 인덱스 손익 분기점은 보통 5~20%의 낮은 수준에서 결정된다.

그리고 CF에 따라 크게 달라지는데 같은 테이블 블록을 여러번 액세스 하면서 논리적 I/O 횟수가 늘고, 물리적 I/O 횟수도 늘기 때문이다.

손익분기점은 CF가 나쁘면 5% 미만에서 결정되며, 심할 때는 1% 미만으로 낮아진다.

반대로 CF가 아주 좋을 때는 손익분기점이 90% 수준까지 올라가기도 한다.

**인덱스 손익분기점과 버퍼캐시 히트율**

일반적으로 말하는 5~20%는 10만 건 이내, 많아도 100만 건 이내 테이블에서 적용되는 수치다.

1000만 건 수준의 큰 테이블에선 손익분기점이 더 낮아진다.

같은 10%여도 10만 건에서 10%는 1만 건, 1000만 건에서 10%는 100만 건이다. 이렇게 조회 건수가 늘 수록 데이터를 버퍼캐시에서 찾을 가능성이 작아지기 때문에 조회 건수가 늘어난 양에 비해 성능이 훨씬 느려질 수 있다.

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

온라인 프로그램은 보통 소량의 데이터를 다루므로 인덱스를 효과적으로 다루는 것이 무엇보다 중요하다.

- 조인을 사용할 때도 대부분 NL 방식(인덱스를 이용하는 방식)을 사용한다.
- 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현 할 수 있다면 온라인 환경에서 대량의 데이터를 조회하더라도 아주 빠른 응답속도를 갖는다.

대량 데이터를 다루는 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다.

- 즉 일부를 빠르게 처리하는 것이 아닌, 전체를 빠르게 처리하는 것을 목표로 해야한다.
- 대량의 데이터를 빠르게 처리하려면 Full Scan과 해시 조인이 유리하다.
- 대량 배치 프로그램에선 인덱스보다 Full Scan이 효과적이지만, 초대용량 테이블은 Full Scan 하면 상당히 오래걸리고, 시스템에 주는 부담도 적지 않기 때문에 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬처리까지 더할 수 있으면 더 좋다.

### 인덱스 컬럼 추가

테이블 액세스를 최소화하기 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.

인덱스 구성을 바꾸면 좋은 상황이 있는데, 실 운영에서는 인덱스 구성을 변경하기가 절대 쉽지 않다.

- 기존 인덱스를 사용하는 다른 SQL이 있을 수 있기 때문이다.
- 할 수 없이 새로 인덱스를 만들게 되면, 점점 인덱스의 수가 늘어날것이고, 이것은 인덱스 관리 비용 증가 및 DML 부하에 따른 트랜잭션 성능 저하로 이어질 수 있다.
- 이런 상황에서 인덱스에 컬럼을 추가하는 것이 도움이 된다.
    - 인덱스 스캔량은 줄지 않지만 테이블 랜덤 액세스 횟수를 줄여주기 때문이다.

### 인덱스만 읽고 처리

테이블 랜덤 액세스가 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면 비효율이 없다.

- 비효율이 없더라도 랜덤 액세스가 많기 때문에 성능이 느릴 수 밖에 없다.
- 이런 경우에 튜닝을 해야한다면 쿼리에 사용된 컬럼을 전부 인덱스에 넣는 방법을 생각할 수 있다.
    - 하지만 추가해야할 컬럼이 많아 실제 적용하기 곤란할 수 있다.

**Include 인덱스**

오라클에는 없지만 SQL Server 2005 버전에 추가된 유용한 기능이다.

- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능이다.
- 다음과 같이 적용할 수 있다.

```sql
// 생성
// 컬럼은 1023개 까지 지정할 수 있다.
create index emp_x01 on emp (deptno) include (sal)
```

순전히 테이블 랜덤 액세스를 줄이는 용도로 개발되었다.

### 인덱스 구조 테이블

랜덤 액세스가 아예 발생하지 않도록 인덱스 구조로 생성한 테이블.

오라클은 IOT(Index-Organized Table)이라고 하며, MS-SQL Server에서는 클러스터형 인덱스라 부른다.

테이블을 찾기 위한 ROWID를 갖는 대신 테이블 데이터를 갖는다.

- 즉, 테이블 데이터를 인덱스 리프 블록에 모두 저장하고 있다.

```sql
// 생성
create table index_org_t (
	a number,
	b varchar2(10),
	constraint index_org_t_pk primary key (a)
) organization index;

// 참고
// 일반적인 테이블은 힙 구조 테이블 이라고 한다.
// 대개 organization 옵션을 생략하지만, 명시할 수도 있다.
create table heap_org_t (
	a number,
	b varchar2(10),
	constraint heap_org_t_pk primary key (a)
) organization heap;
```

일반 힙 구조 테이블에 데이터를 입력할 때는 Freelist로부터 할당 받은 블록에 정해진 순서 없이 데이터를 입력한다. 반면 IOT는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 입력한다.

IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나로, 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여 있으므로 시퀀셜 방식으로 데이터를 액세스한다.

- 이 때문에 Between이나 부등호 조건으로 넓은 범위를 읽을 때 유리하다.
- 데이터 입력과 조회 패턴이 서로 다른 테이블에도 유용하다.

### 클러스터 테이블

클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.

**인덱스 클러스터**

인덱스 클러스터 테이블은 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.

- 한 블록에 담을 수 없을 때는 클러스터 체인으로 연결한다.
- 여러 테이블 레코드를 같은 블록에 저장하기도 하는데, 이를 다중 테이블 클러스터라고 부른다.

```sql
// 클러스터
create cluster c_dept (
	deptno number(2)
) index;

// 클러스터 인덱스
// 데이터 검색 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 때문에 만들어 준다.
create index c_dept_idx on cluster c_dept;

// 클러스터 테이블
create table dept (
	deptno number(2) not null,
	dname varchar2(14) not null,
	loc varchar2(13)
) cluster c_dept(deptno);
```

클러스터 인덱스도 일반 B*Tree 인덱스를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째데이터를 가리킨다.

- 인덱스 레코드와 테이블 레코드는 1 : M 관계를 가진다
- 클러스터 인덱스의 키 값은 항상 Unique하다.
- 이런 특성 때문에 랜덤 액세스가(클러스터 체인을 스캔하면서 발생하는 것을 제외하고) 값 하나당 한 번씩 발생하지 않는다.
- 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽도라도 비효율이 없는게 핵심이다.

**해시 클러스터 테이블**

해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 써서 클러스터를 찾아간다는 점만 다르다.

```sql
// 클러스터
create cluster c_dept (
	deptno number(2)
} hashkeys 4;

// 클러스터 테이블
create table dept (
	deptno number(2) not null,
	dname varchar2(14) not null,
	loc varchar2(13)
) cluster c_dept(deptno);
```