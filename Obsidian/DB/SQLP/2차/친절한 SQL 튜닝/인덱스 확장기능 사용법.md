### Index Range Scan

B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식

인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 필요한 범위만 스캔한다.

선두 컬럼을 가공하지 않은 상태로 저건절에서 사용해야 한다.

### Index Full Scan

수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식

대개 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨

**Index Full Scan의 효용성**

SQL에 선두 컬럼이 조건절에 없으면 옵티마이저는 먼저 Table Full Scan을 고려하지만, 대용량 테이블의 경우 Table Full Scan에 따른 부담이 크다면 옵티마이저는 인덱스 활용을 다시 고려하지 않을 수 없다.

데이터 저장공간은 컬럼 길이 * 레코드 수에 의해 결정되므로 인덱스가 차지하는 면적은 테이블보다 훨씬 적다. Range Scan을 할 수 없을 때 테이블을 스캔하기보다 인덱스 전체를 스캔하는 경우를 생각해보자.

인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면 인덱스를 사용하는 것이 더 유리하다.

**인덱스를 이용한 소트 연산 생략**

Full Scan을 하면 Range Scan과 마찬가지로 결과집합이 인덱스 컬럼 순으로 정렬된다. 따라서 Sort Order By 연산을 생략할 목적으로도 사용할 수도 있다.

하지만 테이블의 데이터들이 대부분 조건을 만족하는 상황에서는 Table Full Scan이 Index Full Scan 보다 더 유리하고, Index Range Scan을 하더라도 마찬가지다.

### Index Unique Scan

수직적 탐색으로만 데이터를 찾는 스캔 방식이다.

Unique 인덱스가 존재하는 컬럼은 중복 값이 입력되지 않게 DBMS가 데이터 정합성을 관리해 준다.

해당 인덱스의 모든 컬럼을 ‘=’ 조건으로만 검색할 때 사용된다.

### Index Skip Scan

오라클이 9i 버전에서 나온 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 스캔방식이다.

이 방식은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 Distinct Value 개수가 많을 때 유리하다.

루트 또는 브렌치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스하는 스캔 방식이다.

**Index Skip Scan 작동 조건**

중간 컬럼에 대한 조건절이 없는 경우에도 사용할 수 있다.

Distinct Value가 적은 두 개의 선두 컬럼이 모두 조건절에 없는 경우에도 유용하게 사용할 수 있다.

### Index Fast Full Scan

말 그대로 Index Full Scan보다 빠른데, 그 이유는 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다.

Multiblock I/O를 사용하므로 대량의 인덱스 블록을 읽어야 할 때 효율적이다.

속도는 빠르지만 결과집합이 인덱스 키 순서대로 정렬되지 않는다.

또한 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어야 하며, 인덱스가 파티션 돼 있지 않아도 병렬 쿼리가 가능하다.