### 인덱스 탐색

루트 블록에는 키값을 갖지 않는 특별한 레코드가 있는데 가장 왼쪽에 있는 LMC(Leftmost Child) 레코드다.

- LMC는 자식 노드 중 가장 왼쪽에 끝에 위치한 블록을 가리킨다.
- LMC가 가리키는 주소로 찾아간 블록에는 키 값을 가진 첫 번째 레코드 보다 작거나 같은 값을 갖는 레코드가 저장되어있다.
- 수직적 탐색을 할 때는 나와있는 블록의 직전 블록으로 가야한다.
    - 예) 루트가 LMC, A, B, C로 되어있다고하고, B를 찾는다고하면 A로 들어가야한다.

### 인덱스 스캔 효율성

인덱스 선행 컬럼이 조건절에 없거나 ‘=’ 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.

**인덱스 스캔 효율성 측정**

인덱스 스캔 효율은 SQL 트레이스를 통해서 쉽게 알 수 있다.

읽은 블록(cr)당 얻은 레코드(Rows)를 보면 된다.

**선두 컬럼, 선행 컬럼**

- 선두 컬럼 : 인덱스 구성상 맨 앞쪽에 있는 컬럼을 지칭할 때 사용한다.
- 선행 컬럼 : 어떤 컬럼보다 상대적으로 앞쪽에 놓인 컬럼을 지칭할 때 사용한다.

### 액세스 조건과 필터 조건

- 인덱스 액세스 조건
    - 인덱스 스캔 범위를 결정하는 조건절
    - 스캔 시작점과 멈추는 지점을 결정하는데 영향을 미치는 조건절이다.
- 인덱스 필터 조건
    - 테이블로 액세스할지를 결정하는 조건절
- 테이블 필터 조건
    - 쿼리 수행 다음 단계로 넘기거나, 최종 결과집합에 포함할지를 결정한다.

**옵티마이저 비용 계산 원리**

비용

= 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용

= 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 + 인덱스 리프 블록을 스캔하는 과정에서 읽는 블록 수 + 테이블 액세스 과정에서 읽는 블록 수

### 비교 연산자의 종류와 컬럼 순서에 따른 군집성

테이블과 달리 인덱스는 같은 값을 갖는 레코드들이 서로 군집해 있다.

선행 컬럼이 모두 ‘=’ 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관 없이 흩어진다.

선행 컬럼이 모두 ‘=’ 조건인 상태에서 첫 번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.

**범위검색 조건 맨 처음과 마지막 구간에서의 액세스 조건**

아래 몇 가지 케이스를 제외하면 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시 된다.

- 좌변 컬럼을 가공한 조건절
- 왼쪽 ‘%’ 또는 양쪽 ‘%’ 기호를 사용한 like 조건절
- 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절
- OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절

### 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

- 인덱스 스캔 효율성은 인덱스 컬럼을 조전절에 모두 등치(=) 조건으로 사용할 때가 가장 좋다.
    - 리프 블록을 스캔하면서 읽은 레코드는 하나도 걸러지지 않고 모두 테이블 액세스로 이어지므로 인덱스 스캔 단계에서의 비효율은 전형 없다.
- 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.
- 반면 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면 인덱스 스캔 단계에서 비효율이 생긴다.

### BETWEEN을 IN-List로 전환

BETWEEN 조건이 앞쪽에 있어서 뒤로 미루면 좋겠지만 운영 시스템에서 그럴 수 없는 경우가 많다.

이럴 때 BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.

- IN-List 개수만큼 UNION ALL 브렌치가 생성되고 각 브랜치 마다 모든 컬럼을 ‘=’ 조건으로 검색하므로 앞서 선두 컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라진다.

**주의 사항**

- IN-List의 개수가 많지 않아야한다.
    - 수직적 탐색이 많이 발생하기 때문이다.
- 멀리 떨어져 있어야 유용하다.
    - 가까이 있으면 수직적 탐색으로인한 블록 I/O가 더 많이 발생한다.

### Index Skip Scan 활용

BETWEEN을 IN-List로 바꾸면 유용한 상황에서 굳이 조건절을 바꾸지 않고도 같은 효과를 낼 방법이 있는데, 바로 Index Skip Scan을 활용하는 것이다.

선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때 Index Skip Scan의 위력이 나타난다.

### IN 조건은 ‘=’인가

IN 조건은 ‘=’이 아니다.

- IN 조건이 ‘=’이 되려면 IN-List Iterator 방식으로 풀려야한다.
- 그렇지 않으면 IN 조건은 필터 조건이다.

**NUM_INDEX_KEYS 힌트 활용**

액세스 조건과 필터 조건을 지정할 때 사용한다.

- (테이블, 인덱스, 인덱스의 몇 번째 컬럼까지만 액세스 조건으로 사용할 지) 이렇게 3개의 인자를 가진다.

### BETWEEN과 LIKE 스캔 범위 비교

BETWEEN이 인덱스 스캔량이 더 적다.

### 다양한 옵션 조건 처리 방식의 장단점 비교

**OR 조건 활용**

- 옵션 조건 처리에 OR 조건을 사용할 수 있다.
    
    ```sql
    where (:cust_id is null or 고객ID = :cust_id)
    ```
    
    하지만 옵티마이저에 의한 OR Expansion 쿼리변환이 작동하지 않으므로 옵션 조건 컬럼을 선두에 두고 인덱스를 구성해도 이를 사용할 수 없다.
    
    - 따라서 선두 컬럼에는 OR 조건을 사용하면 안 된다.
    - 인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 어차피 테이블에서 필터링할 수밖에 없으므로 그때는 OR 조건을 사용해도 무방하다.
    - 따라서 OR 조건을 활용한 옵션 조건 처리는 테이블 필터 조건으로만 사용 가능하다.
        - 단, 인덱스 구성 컬럼 중 하나가 Not Null 컬럼이면 18c부터 인덱스 필터 조건으로도 사용 가능하다.
    - 유일한 장점으로 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과 집합을 보장한다는 것이다.

**LIKE/BETWEEN 조건 활용**

필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면 LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.

- 여기서 필수 조건이 ‘=’이면 옵션 조건인 LIKE/BETWEEN도 인덱스 액세스 조건으로 사용할 수 있다.
- 하지만 아래 4가지 경우에는 반드시 점검해야한다.(BETWEEN은 1, 2번만 확인)
    - 인덱스 선두 컬럼
    - NULL 허용 컬럼
    - 숫자형 컬럼
    - 가변 길이 컬럼

**UNION ALL 활용**

값을 입력했는지에 따라 두 SQL 중 하나만 실행되도록 하면 된다.

```sql
...
where :cust_id is null
...
union all
...
where :cust_id is not null
and 고객ID = :cust_id
...
```

- UNION ALL 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다.
- NULL 허용 컬럼이어도 사용하는데 전혀 문제가 없지만 유일한 단점은 코딩량이 상당히 많아진다는 것이다.

**NVL/DECODE 함수 활용**

```sql
// nvl
where 고객ID = nvl(:cust_id, 고객ID)

// decode
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
```

고객ID 컬럼을 가공했는데도 인덱스가 작동하는 이유는 OR Expansion이 발생했기 때문이다.

- UNION ALL 방식으로 옵티마이저가 쿼리를 변환한 것이다.
- 이 기능이 작동하지 않으면 nvl과 decode는 사용할 수 없다.

가장 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는 데 있다.

- 즉, UNION ALL과 같은 성능을 내면서도 UNION ALL 보다 단순하다.
- 단점은 NULL 허용 컬럼을 쓸 수 없다.

옵션 조건 처리용 NVL/DECODE 함수를 여러 개 사용하면 가자 변별력이 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다.

- 이 기준으로 선택되지 않으면 인덱스 구성 컬럼이더라도 모두 필터 조건으로 처리된다.

### 함수호출부하 해소를 위한 인덱스 구성

**PL/SQL 함수의 성능적 특성**

PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 매우 느리다.

PL/SQL 사용자 정의 함수가 느린 데는 3가지 이유가 있다.

- 가상 머신(VM) 상에서 실행되는 인터프리터 언어
- 호출 시마다 컨텍스트 스위칭 발생
- 내장 SQL에 대한 Recursive Call 발생

오라클은 오라클 서버가 아닌 다른 제품에서도 수행될 수 있도록 PL/SQL을 설계하였다.

그래서 PL/SQL로 작성한 함수와 프로시저를 컴파일하면 바이트 코드를 생성해 데이터 딕셔너리에 저장하며, 이를 해석할 수 있는 PL/SQL 엔진만 있으면 어디서든 실행할 수 있다.

- PL/SQL은 바이트 코드를 런타임 시 해석하면서 실행한다.
- 인터프리터 언어이기 떄문에 Native 코드로 완전 컴파일된 내장 함수에 비해 많이 느리다.

PL/SQL 함수 내부 로직이 너무 복잡하면 그대로 쓸 수밖에 없는데 이럴 때 함수 호출을 줄이는 여러 방법이 있다. 그 중 하나가 액세스 조건을 고려한 인덱스 구성이다.