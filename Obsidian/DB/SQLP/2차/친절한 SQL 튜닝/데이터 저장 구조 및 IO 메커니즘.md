### SQL이 느린 이유

- SQL이 느린 이유는 십중팔구 I/O 때문인데, 정확히는 **디스크 I/O** 때문이다.
- OS 또는 I/O 서브 시스템이 I/O를 처리하는 동안 프로세스는 잠을 잔다.
    - 프로세스는 ‘실행 중인 프로그램이며 그림과 같은 생명주기를 갖는다. 즉 생성(new) 이후 종료(terminated) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복한다. 실행 중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시 실행 상태로 전환한다.
    - 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이런 메커니즘이 필요하다.

![](https://i.imgur.com/aqXF8IV.png)

- 여기서 interrupt 없이 일하던 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 잠시 수면(wating) 상태에서 I/O가 완료되기를 기다리는데, 일하고 있어야 할 프로세스가 잠을 자고 있으니 I/O가 많으면 느릴 수 밖에 없다.
- I/O Call 속도는 Single Block I/O 기준으로 평균 10ms쯤 되는데, 초당 100 블록 쯤 읽는 셈이다.
    - 이 방식으로 10,000 블록을 읽는다면 대략 100초 이상을 기다려야한다.
    - 여기서 여러 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심해지고 그만큼 대기 시간도 늘어나게 된다.

### 데이터베이스 저장 구조

![](https://i.imgur.com/xQ7uBmf.png)

![](https://i.imgur.com/WIodXS0.png)

- 테이블스페이스
    - 세그먼트를 담는 콘테이너이다.
    - 여러 개의 데이터 파일로 구성되어있다.
- 세그먼트
    - 데이터 저장공간이 필요한 오브젝트이다.
    - 여러 익스텐트로 구성된다.
    - 파티션 구조가 아니라면 테이블과 인덱스또한 하나의 세그먼트이다.
    - 만약 파티션 구조라면, 각 파티션이 하나의 세그먼트가 된다.
    - LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.
- 익스텐트
    - 공간을 확장하는 단위이다.
    - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다.
    - 익스텐트는 연속된 블록들의 집합이기도 하다.
- 블록
    - 사용자가 입력한 레코드를 실제로 저장하는 공간이다.
    - DB2, SQL Server같은 DBMS는 블록 대신 페이지(page)라고도 한다.
    - 한 블록은 하나의 테이블이 독점하기 때문에 한 블록에 저장된 레코드는 모든 같은 테이블 레코드다.(다중 테이블 클러스터일 때는 여러 테이블의 레코드가 한 블록에 같이 저장될 수 있다)
    - 한 익스텐트도 하나의 테이블이 독점하기 때문에 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.(MS-SQL Server는 한 익스텐트를 여러 오브젝트가 같이 사용할 수도 있다)

**요약**

- 블록 : 데이터를 읽고 쓰는 단위
- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
- 테이블스페이스 : 세그먼트를 담는 콘테이너
- 데이터 파일 : 디스크 상의 물리적인 OS 파일

```sql
// 오라클에서 세그먼트에 할당된 익스텐트 목록을 조회하는 방법
select segment_type, tablespace_name, extent_id, file_id, block_id, blocks
from dba_extents
where owner = USER
and segment_name = 'MY_SEGMENT'
orderby extent_id;
```

**DBA(Data Block Address)**

모든 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는데, 이 주소값이 DBA이다. → 데이터를 읽으려면 DBA를 확인해야 한다.

인덱스를 이용해 테이블 레코드를 읽을 떄는 인덱스 ROWID를 이용하는데, ROWID는 **DBA + 로우번호(블록 내 순번)**로 구성된다.

### 블록 단위 I/O

블록은 데이터베이스에서 데이터를 읽고 쓰는 단위이며, 오라클은 기본적으로 8KB 크기의 블록을 사용한다.

```sql
// 오라클에서 블록 크기 확인하는 방법
show parameter block_size
or
select value from v$parameter where name = 'db_block_size';
```

테이블 뿐만 아니라 인덱스 또한 블록 단위로 데이터를 읽고 쓴다.

### 시퀀셜 액세스 vs 랜덤 액세스

- 시퀀셜 액세스
    - 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식.
    - 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어있다. 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식을 쓴다.
    - 테이블 블록 간에는 서로 논리적인 연결고리를 갖고 있지 않다.
        - 오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵(map)으로 관리하기 때문에 익스텐트 맵은 각 익스텐트의 첫 번째 블록 주소 값을 갖는다.
        - 익스텐트는 연속된 블록들로 구성되어있기 때문에 저장된 블록을 순서대로 읽고, 이것을 **Full Table Scan**이라 한다.
- 랜덤 액세스 : 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

### 논리적 I/O vs 물리적 I/O

**DB 버퍼 캐시**

- 자주 읽는 블록을 매번 디스크에서 읽는 건 매우 비효율적이기 때문에 모든 DBMS에서 캐싱은 필수이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/42088742-a3a5-4683-b17d-4c52b011a968/b4db5217-7f0f-4ba8-b542-66858e9e9094/Untitled.png)

- **라이브러리 캐시**가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 **코드 캐시**라한다면, **DB 버퍼 캐시**는 **데이터 캐시**라 할 수 있다.
- 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 **반복적인 I/O Call**을 줄이는 데 목적이 있다.

```sql
// 오라클 SQL*Plus에서 버퍼 캐시 사이즈 확인
show sga
```

**논리적 I/O vs 물리적 I/O**

- 논리적 블록 I/O : SQL을 처리하는 과정에 발생한 총 블록 I/O(메모리상의 버퍼캐시를 경유하므로 메모리 I/O가 곧 논리적 I/O라고 생각해도 된다)
- 물리적 블록 I/O : 디스크에서 발생한 총 블록 I/O(SQL 처리 도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O한다)
- 메모리 I/O는 전기적 신호인데 반해 물리적 I/O는 액세르 암(Arm)을 통해 물리적 작용이 일어나므로 보통 10,000배 쯤 느리고, 디스크 경합이 심하면 더 느리다.
- SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O다.
- 디스크에서 읽은 블록I/O가 물리적 I/O다.

**버퍼캐시 히트율(BCHR)**

${({캐시에서 곧바로 찾은 블록 수 \over 총 읽은 블록 수}) * 100}$

${ = {((논리적 I/O - 물리적 I/O) \over 논리적 I/O)} * 100}$

${ = (1 - {(물리적 I/O) \over (논리적 I/O)}) * 100}$

${=(1-({Disk\over(Query + Current)})) * 100}$

위 공식과 같이 BCHR은 읽은 전체 블록 중 물리적인 디스크 I/O를 수반하기 안혹 곧바로 메모리에서 찾은 비율을 나타낸다.

온라인 트탠젝션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야한다.

물리적 I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야한다. 아래 공식을 보면 알 수 있다.

${물리적 I/O = 논리적 I/O * (100\% - BCHR)}$

SQL을 튜닝하므로써 논리적 I/O를 줄여서 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다.

**Single Block I/O vs Multiblock I/O**

- Single Block I/O : 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
- Multiblock I/O : 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식
- 인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다.
- 인덱스 Single Block I/O Operation
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

소랑의 데이터를 읽을 때는 Single Block I/O가 효율적이다.

반대로 많은 블록을 읽을 때는 Multiblock I/O가 효율적이다. ⇒ 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 사용

Multiblock I/O의 단위를 크게 설정하면 포로세스가 잠자는 횟수가 줄기때문에 성능이 좋아진다.

```sql
// multiblock I/O 단위 
show parameter db_file_multiblock_read_count
```

Multiblock I/O는 인접한 블록을 읽기 때문에 익스텐트는 넘지 못한다.

### **Table Full Scan vs Index Range Scan**

- Table Full Scan : 테이블 전체를 스캔해서 읽는 방식
- Index Range Scan : 인덱스를 이용해 읽는 방식

한 번에 많은 데이터를 처리하는 집계용 SQL과 배치 프로그램은 Table Full Scan이 더 유리하다.(조인을 포함한다면 해시 조인으로 유도한다)

Table Full Scan : 시퀀셜 액세스, Multiblock I/O(많은 데이터를 찾을 때)

Index Range Scan : 랜덤 액세스, Single Block I/O(적은 데이터를 찾을 때)

**인덱스에 대한 맹신은 금물이다.**

### 캐시 탐색 메커니즘

- 버퍼 캐시 탐색 Operation
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
    - 테이블 블록을 Full Scan 할 때
- DBMS는 버퍼 캐시를 해시 구조롤 관리한다.
- 해시 구조의 특징
    - 같은 입력 값은 항상 동일한 해시 체인(버킷)에 연결됨
    - 다름 입력값이 동일한 해시 체인에 연결될 수 있음
    - 해시 체인 내에서는 정렬이 보장되지 않음

**메모리 공유자원에 대한 액세스 직렬화**

버퍼 캐시에 캐싱된 버퍼블록은 모두 공유 자원이다.

하나의 버퍼 블록을 2개 이상의 프로세스가 ‘동시에’ 접근하려고 할 때 문제가 발생한다.

- 동시에 접근하면 블록 정합성에 문제가 생길 수 있음
- 내부에서 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위해 직렬화(serialization) 메커니즘이 필요하다
- 2개 이상의 프로세그가 같이 사용하는 것처럼 보이지만, 어느 한 순간에는 한 프로세스만 사용할 수 있도록 지원해는 메커니즘이 래치(Latch)다.

**캐시 버퍼 체인 래치**

대량의 데이터를 읽을 때 모든 블록에 대해 해시 체인을 탐색하는데, DBA를 해시 함수에 입력하고, 거기서 반환된 값으로 스캔해야할 해시 체인을 찾는다.

체인을 스캔하는 동안 다른 프로세스가 체인 구조를 변경하는 일이 생기면 안돼기 때문에, 이를 막기 위해 해시 체인 래치가 존재한다.

SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하는데, 버퍼캐시는 캐시 버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 작동한다.

래치에 의한 경합 때문에 캐시 I/O도 생각만큼 빠르지 않을 수 있다.

캐시 버퍼 체인뿐만 아니라 버퍼 블록 자체에도 직렬화 메커니즘이 존재하는데, 바로 ‘버퍼 Look’이다.

**버퍼 Look**

래치를 해제한 상태로 버퍼 블록 데이터를 읽고 쓰는 도중에 후행 프로세스가 하필 같은 블록에 접근해서 데이터를 읽고 쓴다면 데이터 정합성에 문제가 생길 수 있다. 이를 방지하기 위해 버퍼 Look을 사용한다.

캐시 버퍼 체인 래치를 해제하기 전에 버퍼 헤더에 Lock을 설정함으로써 버퍼 블록 자체에 대한 직렬화 문제를 해결하는 것이다.