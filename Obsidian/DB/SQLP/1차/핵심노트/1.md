**가장 일반적인 전용(Dedicated) 서버구성을 전제로 할 때 오라클 메모리 구성요소**

- PGA
- UGA
- CGA

**오라클 데이터베이스 저장구조**

- 한 테이블 스페이스에 여러 세그먼트가 속하지만 여러 데이터 파일에 걸쳐 저장됨
- 세그먼트는 익스텐트의 집합이다
- 익스텐트는 연속된 블록의 집합이다
- 한 익스텐트에 저장된 블록은 모두 같은 데이블 블록이다

**Write Ahead Logging**

- 버퍼캐시에 있는 블록 버퍼를 개신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 하고, DBWR가 버퍼캐시로부터 Dirty 블록들을 디스크게 기록하기 전에 먼저 LGWR가 해당 Redo엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야 한다

**Log Force at Commit**

- DML을 수행하는 사용자 프로세스가 로그 버퍼에 호그를 기록하고 데이터 블록을 변경한다. 이후 Log Writer가 주기적으로 로그 버퍼 엔트리를 Redo 로그 파일에 기록하는데, 메모리상의 로그 버퍼는 언제든 유실될 가능성이 있다. 따라서 트랜잭션의 영속성을 보장하려면 최소한 커밋 시점에는 로그를 메모리가 아닌 디스크 파일에 안전하게 기록하야 한다

**Fast Commit**

- 사용자가 요구한 갱신 사항을 휘발성인 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록하지 않았더라도 Redo로그를 믿고 빠르게 커밋을 완료하는 메커니즘

**Delayed Block Cleanout**

- 변경된 블록을 커밋 시점에 바로 Cleanout하지 않고 그대로 두었다가 나중에 해당 블록을 처음 읽는 세션에 의해 정리되도록하는 것

**오라클 버퍼 블록이 놓일 수 있는 상태**

- Free 버퍼
- Dirty 버퍼
    - Clean 버퍼
- Pinned 버퍼

**오라클 데이터베이스 I/O**

- I/O모델에서는 예상 I/O Call, CPU모델에선 CPU사용량을 감안하지만 예상 I/O Call횟수가 절대적임
- SQL이 느린 대부분은 디스크 I/O다
- 블록단위 I/O인데 요즘에는 대량테이터나 온라인 트랜잭션 환경에서 블록사이즈를 기본으로 많이 사용한다
- Index Range Scan은 SingleBlock I/O이다

**DB 버퍼캐시 경합과 관련있는 것**

- latch: cache buffers chains
- buffer busy waits
- free buffer waits

**디스크에서 블록을 읽을 때 Multiblock I/O를 사용하는 오퍼레이션**

- Table Full Scan
- Index Fast Full Scan

**Index Range Scan 사용조건**

- 선두컬럼이 가공되지 않은 채로 조건절에 있어야함
- 부정형이면 안됨

**OR 조건일 때 옵티마이저의 스캔 방식 선택**

- 기본적으로 Table Full Scan을 사용
- 힌트로 index를 사용하면 Index Full Scan을 사용한다

**인덱스 설계시 고려해야 할 요소**

- 기존 인덱스 개수
- 데이터양과 DML 발생빈도
- SQL 수행 빈도

**소트 머지 조인**

- 인덱스가 없어도 상관없음
- 양쪽 테이블 모두 조건절 범위에따라 유불리가 생성

**조인에 관한 설명**

- 부분범위 처리가 효과적인 상황에서는 NL조인이 가장 유리하다
- 소량 조인일 때는 항상 NL조인이 가장 유리하다
- 조건 중 하나라도 ‘=’조건이면 해시조인을 할 수 있다
- 해시 조인 시 Build Input으로 선택된 집합의 조인 컬럼에 중복값이 많으면 비효율적이다
- NL조인은 한 레코드씩 진행된다. 세개 이상의 테이블을 할 때도 마찬가지다
- 해시 조인도 레코드 단위 처리가 가능하다
- 소트 머지 조인은 레코드 단위 처리가 불가능하다

**Library Cache에 관한 설명**

- SGA의 구성요소이다
- SQL과 실행계획을 캐싱한다
- PL/SQL 프로그램을 캐싱한다

**바인드 변수에 관한 설명**

- 컬럼 히스토그램을 사용하지 못하지만, 그 외의 통계정보는 활용함
- 옵티마이저는 통계정보 상의 레코드 수를 컬럼 값의 종류 개수로 나눠서 카디널리티를 계한. 즉 컬럼값 별로 균등한 분포를 갖는다고 가정
- 바인드 변수 Peeking은 부작용이 심해 잘 사용하지 않음
- CURSOR_SHARING 파라미터를 FORCE로 설정하면 옵티마이저가 상수 조건 값을 강제로 바인드 변수화 한다. 이 옵견을 적용하면 실행계획이 매우 불안정해지므로 운영 중에 되도록 사용하지 않아야 한다. 바인드 변수를 사용하지 않고 개발한 SQL이 너무 많아 하드파싱 부하 때문에 시스템을 정상 가동할 수 없을 때 임시방편으로 사용을 고려할 수 있으나, 많은 실행계획 검증과 성능 테스트를 거친 후 적용해야 한다. 근본적인 해법은 바인드 변수를 사용해서 재개발하는 것이다

**통계정보를 수집하면 좋은 이유**

- 통계정보가 실제 데이터 상황을 잘 반영하면 더 좋은 실행계획을 얻을 수 있다. 좋은 실행계획이란 I/O를 최소화할 수 있는 실행계획을 말한다. 성능은 I/O 발생량에 의해 결정되기 때문이다. 이것이 통계정보를 수집하는 궁극적인 이유다.

**대량 데이터를 일괄 insert하는 배치 프로그램을 튜닝**

- 인덱스를 UNUSABLE로 전환했다 INSERT 완료 후에 재생성
- Direct Path Insert 기능을 활용한다
- NOLOGGING 옵션을 활용한다

**Direct Path Write**

- Exclusive 모드 TM Lock을 설정함
- SQL*Loader(sqlldr)에서 direct 옵션을 true로 설정
- PARALLEL DML
- CTAS(CREATE TABLE AS SELECT)

**데이터베이스 Call과 네트워크 부하를 줄이는 튜닝**

- DB 서버로부터 대량 데이터를 추출할 때 Array Size를 늘린다
- 대량 데이터를 INSERT 할 때 Array Processing 기능을 활용한다
- 스칼라 서브쿼리를 일반 조인문으로 변경한다

**List 파티션**

- 불연속적인 값 목록에 대해 사용자가 정의한 그룹으로 데이터를 분할하고자 할 때 좋다

**MVCC모델을 사용하는 DBMS의 특징**

- 트랜잭션의 일관성이 좋다
- 트랜잭션의 동시성이 좋다
- 쿼리의 일관성 유지를 위해 Undo 데이터를 읽는 과정에 에러가 발생할 수 있다

**초대용량 인덱스 생성시 필요 쿼리**

```sql
alter session set workarea_size_policy = menual;
alter session set sort_area_size = 1000000000;
```

**트랜잭션의 특징**

- Atomicity(원자성)
- Cosistency(일관성)
- Isolation(격리성)
- Durablility(영속성)

**SQL 파싱 최적화 과정**

- Parser
- Query Transformer
- Plan Generator & Estimator
- Row-Source Generator