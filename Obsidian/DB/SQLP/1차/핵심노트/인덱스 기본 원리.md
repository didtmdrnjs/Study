**B*Tree 인덱스 구조**

- 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다.
- 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다.
- 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
- 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다.
- 리프 블록의 각 로우와 테이블 로우 간에는 1:1 관계다.
- 리프 블록끼리는 이중연결리스트(double linked list) 구조다.

**인덱스 ROWID**

- 초기는 (데이터파일 번호 + 블록 번호 + 블록 내 로우 번호)로 구성.
- Oracle 8 부터는 (오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우 번호)로 구성.

**인덱스 탐색**

- 루트에서 리프 블록 까지 수직적 탐색을 통해 시작점을 찾음.
- 첫 번째 레코드를 찾은 뒤 리프 블록들을 수평적 탐색하면서 데이터를 찾는다.

**클러스터형 인덱스**

- 클러스터형 인덱스가 있는 경우
    - WITH절에 INDEX(1)으로 하면 클러스터형 인덱스를 검색
    - WITH절에 INDEX(0)으로 하면 클러스터형 인텍스를 스캔
- 클러스터형 인덱스가 없는 경우
    - WITH절에 INDEX(0)으로 하면 테이블을 Full Scan한다.
    - WITH절에 INDEX(1)으로 하면 구문 오류가 난다.

**Index Range Scan의 조건**

- where절에 선두 컬럼에 대한 조건이 명시되야 한다.

**INDEX FULL SCAN**

- 인덱스 리프 블록을 처음부터 끝까지 스캔
- 선두컬럼이 조건절에 없을 때 사용
- FULL SCAN이라면 만족하는 데이터가 적을 수록 유리함.
- 부분 스캔이라면 만족하는 데이터가 많을 수록 유리함.

**INDEX UNIQUE SCAN**

- 인덱스에 있는 모든 컬럼을 ‘=’ 조건으로 검색해야함.(일부라면 Range Scan을 한다.)

**INDEX FAST FULL SCAN**

- 논리적인 연결을 따르지않고 물리적인 순서대로 익스텐트 전체를 Multiblock I/O를 수행한다.
- 순서를 보장하지 않는다.

**INDEX SKIP SCAN**

- 조건절에서 누락된 인덱스 선두 컬럼에 대한 IN 조건절을 추가해 주는 튜닝 기법과 비슷하지만, 스캔원리는 다름.
- IN 조건절을 강제로 추가하는 일은 있을 수 없다.

**Index Fragmentation**

- Index Skew는 인덱스 엔트리가 왼쪽 또는 오른쪽으로 치우치는 현상을 의미함.
- Index Sparse는 블록 전반에 걸쳐 밀도(density)가 떨어지는 현상을 의미함.

**비트맵 인덱스**

- 개수가 적을 때 효율적(B*Tree인덱스 보다 적은 용량을 차지) ⇒ 대용량에 유용.
- 여러개 동시에 사용 가능.
- 정형화 되지 않은 임의 질의가 많은 대용량 DW/OLAP 환경에 적합.
- Lock에 의한 DML 부하가 심함.

**함수기반 인덱스**

- 조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 Range Scan이 불가능한데, 인덱스에 함수를 적용한 상태로 값을 저장하면 정상적인 Range Scan이 가능함.

**리버스 키(Reverse Key) 인덱스**

오름차순 한 방향으로만 값이 증가하는 컬럼에 인덱스를 생성하면, 동시에 INSERT 하려는 다중 트랜젝션에 의해 맨 우측 리프블록에서 경합이 발생할 수 있는데 그럴 때 인덱스 키 값을 역으로 변환해 저장하면 신규로 INSERT하는 값들이 여러 리프 블록에 흩어지므로 경합도 줄어듦.

**PK 컬럼 인덱스**

- 오라클은 PK컬럼으로 IOT를 정의 해야함.
- SQL Server에서 클러스터형 인덱스는 PK컬럼으로 할 필요가 없음.
- 둘다 테이블에 하나만 생성가능

**Index Range Scan 불가 조건**

- 인덱스 액세스 조건 컬럼을 조건절에서 가공하는 경우.
- Like로 중간 값을 검색 할 때
- 부정형 비교 조건
- 인덱스의 모든 컬럼이 NULL이 허용인 경우 ISNULL로 할 수 없다
- 타입이 맞지 않을