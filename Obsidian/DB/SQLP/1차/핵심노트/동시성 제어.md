**동시성 제어**

- 일관성은 데이터 품질과 관련있다
- 동시성은 프로그램 성능과 관련있다.
- 다중 사용자의 접속을 허용하지 않는 독립(Stand-alone) DB에서는 동시성 제어가 불필요하다
- 비관적 동시성 제어 : 비관적인 시각으로 동시성을 제어할 때는 현재의 트랜잭션의 데이터를 읽어서 연산하는 과정에 다른 트랜색션이 해당 데이터를 수정할 가능성이 매우 높다고 보고 데이터를 읽는 시점부터 아예 Lock을 설정하나다
- 낙관적 동시성 제어 : 낙관적인 시각으로 동시성을 제어할 때는 현재의 트랜잭션이 데이터를 읽어서 연산하는 과정에 다른 트랜잭션이 해당 데이터를 수정할 가능성이 매우 낮다고 보고 데이터를 읽는 시점에는 일다 Lock을 설정하지 않는다. 하지만, 그 데이터를 다른 트랜잭션이 변경했을 가능성이 있으므로 이후에 같은 데이터를 다시 읽거나 변경할 때는 반드시 변경 여부를 확인해야 한다.

**Lock에 의한 트랜잭션 성능 저하를 막기 위해 사용할 수 있는 방안**

- SELECT FOR UPDATE 문에 WAIT 옵션을 사용한다
- SELECT FOR UPDATE 문에 NOWAIT 옵션을 사용한다
- 낙관적 동시성 제어를 사용한다

**트랜잭션의 동시성 향상을 위한 제언**

- 동시성을 높이려면 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋하도록 구현하는 것이 바람직하다
- 대량 데이터를 일괄 갱신하는 배치(Batch) 프로그램은 가급적 야간 시간대에 수행한다
- Lock 경합 해소를 위한 프로그램 로직 개선에 앞서 SQL 튜닝을 선행해야 한다

**다중버전 동시성 제어**

- 일관성과 동시성이 모두 좋다
- 문장 수준의 일관성은 완벽하게 보장하지만, 트랜잭션 수준의 일관성까지 보장하지는 않는다. 몰론 트랜잭션 격리성 수준을 Serializable로 상향 조정하면 트랜잭션 수준의 일관성까지 보장하지만, 이는 다른 DBMS도 마찬가지이다
- Snapshot too old 에러는 튜닝을 통해 줄일 수는 있어도 완전히 해소하기 어렵다
- Undo 데이터를 관리하고, 버퍼캐시에서 CR Copy 블록을 여러 개 관리하는 데 따른 성능저하가 발생함

**Snapshot too old(ORA-01555) 에러를 줄이기 위한 방안**

- fetch across commit 형태의 프로그램 작성을 지양한다
- 결과집합의 정렬이 불필요하더라도 SELECT 문에 ORDER BY를 추가한다
- 대량 Update 후에 곧바로 해당 테이블을 Full Scan 하는 쿼리를 수행한다