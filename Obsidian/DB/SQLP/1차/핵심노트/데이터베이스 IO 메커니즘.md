**블록단위 I/O**

오라클을 포함한 모든 DBMS에서 I/O는 블록(다른 DBMS는 페이지라고 함) 단위로 이루어 진다. 즉 하나의 레코드를 읽더라도 레코드가 속한 블록 전체를 읽는다.

블록 단위 I/O는 버퍼캐시와 데이터파일 I/O 모두에 적용된다.

- 데이터 파일에서 DB 버퍼캐시로 블록을 적재 할 때
- 데이터 파일에서 블록을 직접 읽고 쓸 때(Direct Path I/O)
- 버퍼캐시에서 블록을 읽고 쓸 때
- 버퍼캐시에서 변경된 블록을 데이터 파일에 쓸 때

데이터 딕셔너리에 저장된 테이블 및 컬럼 정보를 딕셔너리 캐시에 적재 할 때는 로우 단위로 I/O한다. 딕셔너리 캐시를 로우 캐시(Row Cache)라고도 부르는 이유다.

**같은 조건의 SQL문에서 Select하는 컬럼의 수가 다를 때**

- 컬럼의 수가 더 많은 쪽이 더 많은 공간을 사용하고, 네트워크 전송량도 많다.
- 두 SQL이 읽는 블록의 수는 Table Full Scan 할 때 서로 같을 뿐만 아니라 인덱스를 이용 할 때도 같다. ⇒ 블록 단위로 I/O하기 때문. ⇒ 하지만 인덱스에다가 컬럼의 수가 더 적은 쪽에 나머지 컬럼들을 추가 해주면 더 적은 쪽이 더 적은 량의 블록을 읽는다. ⇒ 테이블 액세스 없이 인덱스만으로 결과 집합을 생성할 수 있기 때문.

**버퍼캐시 탐색 메커니즘**

Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.

- 아래 오퍼레이션은 모두 버퍼캐시 탐색 과정을 거친다.
- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 블록을 Full Scan 할 때

**버퍼캐시 히트율을 구하는 공식**

$$ BCHR = (1 - (물리적 I/O) / (논리적 I/O)) * 100 $$

- 트레이스 정보에서 disk값이 물리적 I/O이고, query값과 current값을 더한 값이 논리적 I/O이다.

**LRU 알고리즘**

모든 DBMS는 사용 빈도가 높은 데이터 블록들이 버퍼 캐시에 오래 남아있도록 하기 위해 LRU 알고리즘을 사용한다. 모든 버퍼 블록 헤더를 LRU 체인에 연결해서 사용빈도에 따라 수시로 위치를 옮기다가, Free 버퍼가 필요해질 때면 액세스 빈도가 낮은 데이터 블록들을 우선하여 밀어낸다. 그러면 자주 액세스되는 블록들이 캐시에 더 오래 남게 된다.

**시퀀셜 액세스 vs 랜덤 액세스**

- 시퀀셜(Sequential) 액세스 : 논리적 또는 물리적으로 연결된 순서에 따라 차례로 블록을 읽어나가는 방식(인덱스와 테이블을 스캔 할 때 이 방식을 사용).
- 랜덤(Random) 액세스 : 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다(인덱스를 스캔해서 얻은 ROWID로 테이블 블록을 액세스 할 때 이 방식을 사용).

**Single Block I/O**

인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다.

- 아래 목록이 Single Block I/O 대상 오퍼레이션이다. (인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다.
- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

테이블을 Full Scan 하거나 인덱스를 Fast Full Scan 할 때는 Multiblock I/O 방식을 사용한다.

Single Block I/O를 모니터링해 보면 db file sequential read 대기 이벤트가 나타난다.

**Multiblock I/O**

- Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 ‘인접한’ 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다. Multiblock I/O 단위는 db_file_multiblock_read_count 파라미터에 의해 결정됨.
- 인접한 블록이란 같은 익스텐트에 속한 블록을 의미하며, Multiblock I/O 방식으로 읽더라도 익스텐트 경계를 넘지 못한다.

Multiblock I/O를 모니터링해 보면 db file scattered read 대기 이벤트가 나타난다.