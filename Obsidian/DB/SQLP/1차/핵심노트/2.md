**오라클 리스너**

- 클라이언트로부터 연결 요청을 받는 프로세스다
- 전용 서버 방식 : 서버 프로세스를 생성한다
- 공유 서버 방식 : 가용한 Dispatcher 포트번호를 클라이언트에 전송한다

**오라클 익스텐트**

- 익스텐트는 테이블스페이스로부터 공간을 확장하는 단위이며, 연속된 블록들의 집합이다
- 익스텐트 내 블록은 서로 인접한 연속된 공간, 하지만 익스텐트끼리는 연속되지 않음

**Redo 로그 사용 목적**

- Database Recovery
- Cache Recovery
- Fast Commit

**SQL 특질**

- 구조적
- 집합적
- 선언적

**SELECT 하는 컬럼수가 많을 때**

- 클라이언트 측에 더 많은 데이터를 전송한다
- 클라이언트 측에서 더 많은 CPU를 사용한다
- 서버 측에서 더 많은 메모리를 사용한다

**DBMS_XPLAN.DISPLAY_CURSOR 함수**

- 라이브러리 캐시에 적재된 커서의 실제 실행계획을 출력할 때 사용할 수 있다
- 라이브러리 캐시에 적재된 커서의 트레이스 정보를 출력할 때 사용할 수 있다.
- V$SQL_PLAN, V$SQL_PLAN_STATISTICS_ALL 뷰와 관련이 있다

**AWR 보고서 해석**

- 인스턴스 효율성 항목들은 100%에 가까울수록 좋다
- 부하 프로파일 항목들에 나타난 수치의 크기를 단순 분석하는 것은 큰 의미가 없으며, 시스템이 정상적으로 작동하던 시점과 비교하거나 동종업계 타시스템과 비교해 본다면 성능 관련 문제점과 시사점을 발견하는 데 큰 도움을 받을 수 있다
- 최상위 대기 이벤트에는 CPU time이 최상위에 위치하는 것이 좋다

**클러스터링 팩터가 좋으면 생기는 현상**

- 테이블 액세스 과정에서 읽는 블록 개수가 줄어듬
- DB 버퍼캐시에서 읽는 블록 개수가 줄어든다
- 물리적으로 디스크에서 읽는 블록 개수가 줄어든다
- 테이블 스캑 대비 인덱스를 이용한 테이블 애세스의 손익분기점이 높아진다. 즉 인덱스의 효율성이 좋아짐

**인덱스 순서 결정시 고려해야할 사항**

- ‘=’ 연산자를 사용하는 컬럼 선정
- order by 절에 기술한 컬럼 추가
- ‘=’ 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

**NL 조인**

- 선행 집합의 처리 범위에 의해 전체일량이 결정됨
- 후행 집합을 액세스할 때 사용하는 인덱스의 효율성이 무엇보다 중요
- 선행 집합은 Table Full Scan이 더 유리할 수 있음
- 아무리 완벽한 인덱스라도 대량 데이터 조인은 불리함

**해시 조인**

- 해시 방식으로 조인 할 때 조인 대상 집합을 읽을 때는 SGA 버퍼캐시에서 데이터를 읽는다
- 해시 맵은 PGA에 생성하므로 데이터를 찾는 과정에 래치 및 버퍼 Lock을 획득하지 않는다. 이게 대량 데이터 조인을 할 때 빠른 이유다
- 해시 맵에서 조인에 성공한 레코드에 대해 나머지 컬럼을 읽기 위해 테이블 블록을 랜덤 액세스해야 한다면 해시 조인을 사용할 이유가 없다. 해시 조인은 NL 조인의 가장 큰 부담 요소인 테이블 랜덤 액세스를 줄이기 위해 개발된 조인 메소드라는 사실을 기억하기 바란다.
- 조인 대상 집합이 양쪽 모두 커서 해시맵이 Hash Area 크기를 초과하면 Temp 테이블스페이스를 이용한다.

**SQL 옵티마이저의 역할**

- 사용자로부터 전달받은 쿼리를 최적화하기 쉬운 형태로 변환한다
- 후보군 실행계획들을 생성한다
- 각 실행계획의 선택도, 카디널리티, 비용을 계산한다

**라이브러리 캐시에서 SQL을 탐색하고 파싱하는 부하를 줄이기 위한 방법**

- 바인드 변수를 사용한다
- 애플리케이션 커서 캐싱 기능을 활용한다
- session_cached_cursors 파라미터 설정 값을 늘린다

**바인드 변수**

- 사용자가 다르면 다른 커서를 사용한다
- 히스토그램이 수집돼 있는 컬럼의 NDV가 적고 분포가 균일하지 않다면, 바인드 변수보다 상수값을 사용하는 것이 좋다
- 항상 바인드 변수를 사용하는 컬럼에는 히스토그램을 수집하지 않아도 된다
- DW, Data Mart 등 정보계성 시스템에서는 온라인 트랜잭션을 처리하는 시스템과 비교해 바인드 변수의 중요성이 크지 않다

**INSERT INTO SELECT 구문에 APPEND 힌트를 썼을 때 성능이 좋아지는 이유**

- Freelist를 조회하지 않고, HWM 바깥 영역에 순차적으로 입력한다
- Undo 로깅을 최소화한다
- 버퍼캐시를 경유하지 않는다

**Array Size를 늘리면 얻는 효과**

- 블록 I/O가 줄어든다
- 데이터베이스 Call 횟수가 준다
- 각 Fetch Call에 대한 반응속도가 느려진다
- INSERT INTO … SELECT는 영향을 받지 않는다

**부분범위 처리**

- 결과집합을 전송할 때 DBMS는 항상 일정량씩 나눠서 전송하며, 이를 활용해 일정량씩 나눠서 출력할지, 아니면 전체를 모두 출력할지는 클라이언트 프로그램에 의해 결정

**프로세스 사용 개수**

- PARALLEL의 나누는 개수 * 2 + 1(QC 포함)

**트랜잭션에 의한 데이터 정합성을 유지하면서 Lock에 의한 성능 저 최소화**

- 원자성을 훼손하지 않는 범위에서 트랜잭션은 가능한 짧게 정의한다
- 온라인 트랜잭션에서 자주 변경하는 데이터를 배치 프로그램에서 동시에 변경하지 않도록 프로그램을 설계하거나 시간대를 조절한다
- SELECT FOR UPDATE 문을 사용한다
- 단일 컬럼의 일련번호 값을 입력할 때는 가급적 시퀀스 기능을 활용한다

**TM Lock**

- DML을 수행하는 테이블마다 자동으로 설정한다
- 인덱스를 생성할 때는 테이블에 Share모드 TM Lock을 설정한다
- APPEND 방식으로 INSERT 할 때는 테이블에 Exclusive 모드 TM Lock을 설정한다

**Checkpoint**

- 새로운 데이터 블록을 적재할 버퍼캐시 공간을 확보함은 몰론 장애 발생 시 복구 시간을 최소화하기 위해 주기적으로 전체 또는 일정량의 Dirty 버퍼를 데이터파일에 기록하는 과정

**카디널리티 개수**

- (1/조건절에 나온 컬럼의 NDV) * 총 로우수

**이상현상**

- Dirty Read
- Non-Repeatable Read
- Phantom Read