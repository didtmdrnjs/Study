Database : 오라클에서는 디스크에 저장된 데이터 집합(Datafile, Redo Log File, Control File 등).

Instance : SGA 공유 메모리 영역과 이를 액세스 하는 프로세스 집합.

기본적으로 하나의 인스턴스가 하나의 데이터베이스만 액세스하지만, RAC(Real Application Cluster) 환경에서는 여러 인스턴스가 하나의 데이터베이스를 액세스 할 수 있다. 하지만 하나의 인스턴스가 여러 데이터베이스를 액세스 할 수는 없다.

**백그라운드 프로세스**

- System Monitor(SMON) : 장애가 발생한 시스템을 재기동 할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링한다.
- Process Monitor(PMON) : 이상이 생긴 프로세스가 사용하던 리소스를 복구한다.
- Database Writers(DBWn) : 버퍼캐시에 있는 Dirty 버퍼를 데이터 파일에 기록한다.
- Log Writer(LGWR) :로그 버퍼 엔트리를 Redo 로그 파일에 기록한다.
- Archiver(ARCn) : 꽉 찬 Redo 로가가 텊어 쓰여지기 전에 Archive 로그 디렉토리로 백업한다.
- Checkpoint(CKPT) : Checkpoint 프로세스는 이전에 Checkpoint가 일어났던 마지막 시점 이후의 데이터베이스 변경 사항을 데이터 파일에 기록하도록 트리거링 하고, 기록이 완료되면 현재 어디 까지 기록 했는지를 컨트롤 파일과 데이터 파일 헤더에 저장한다.(더 자세히 하면 Write Ahead Logging방식(데이터 변경 전에 로그부터 남기는 메커니즘)을 사용하는 DBMS는 Redo 로그에 기록해 둔 버퍼 블록에 대한 변경사항 중 현재 어디까지를 데이터 파일에 기록했는지 체크포인트 정보를 관리해야 한다. 이는 버퍼캐시와 데이터 파일이 동기화 된 시점을 가리키며, 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스를 복구할 수 있도록 하는 용도로 사용된다. 이정보를 갱신하는 주기가 길수록 장애 발생 시 인스턴스 복구 시간도 길어진다.
- Recoverer(RECO) : 분산 트랜잭션 과정에 발생한 문제를 해결한다.
- 로그버퍼에 로그를 기록하는 것은 백그라운드 프로세스가 아니라 DML을 수행하는 각 사용자 프로세스다. 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한 이후 Log Writer(LGWR)가 주기적으로 로그 버퍼 엔트리를 Redo 로그 파일에 기록한다.

**데이터 저장 구조**

- 블록 : 대부분 DBMS는 블록 단위로 I/O한다. 이는 하나의 레코드에서 하나의 컬럼만 읽더라도 그것이 속한 블록을 통째로 읽게 됨을 뜻한다.
- 익스텐트 : 공간을 확장하는 단위다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스(물리적으로는 데이터 파일)로 부터 추가적인 공간을 할당 받는데, 이 때 정해진 익스텐트 크기의 연속된 블록을 할당 받는다.
- 세그먼트 : 데이터 저장공간을 사용하는 오브젝트(테이블, 인덱스, 파티션, 클러스터, LOB등)를 저장공간을 사용하지 않는 오브젝트(뷰, 시너님, 시퀀스, 함수, 프로시저, 트리거 등)와 구분해서 세그먼트라고 부른다. 저장공간을 사용한다는 것은 테이블스페이스로 부터 한 개 이상의 익스텐트를 할당받음을 뜻한다. 세그먼트는 **익스텐트의 집합**이라고 말할 수 있는데, 익스텐트끼리 서로 인접하지는 않는다.
- 테이블스페이스 : 세그먼트를 담는 컨테이너로서, 여러 데이터 파일로 구성된다. 각 세그면트는 정확히 한 테이블스페이스에 속하지만, 한 테이블스페이스에는 여러 세그먼트가 존재 할 수 있다. 한 세그먼트는 여러 데이터 파일에 걸쳐 저장된다. 한 테이블스페이스가 여러 데이터 파일로 구성되기 때문이다.

![](https://i.imgur.com/zwHGMlq.png)

**Undo를 사용하는 목적**

- Transaction Rollback
- Transaction Recovery(Instance Recovery 시 rollback 단계)
- Read Consistency

**Redo 로그를 사용하는 목적**

- Database Recovery(Media Recovery) ⇒ 물리적 결함 시 복구
- Cache Recovery(Instance Recovery시 roll forward 단계) ⇒ 트렌잭션 데이터 유실에 대비(인스턴스 캐시 복구)
- Fast Commit

**Redo 메커니즘**

- Log Force at commit : DML을 수행하는 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한다. 이후 Log Writer(LGWR) 가 주기적으로 로그 버퍼 엔트리를 Redo 로그 파일에 기록하는데, 메모리상의 로그 버퍼는 언제든 유실 될 수 있다. 따라서 트랜젝션의 영속성을 보장하려면 최소한 커밋 시점에는 로그를 메모리가 아닌 데이터 파일에 안전하게 기록해야 한다.
- Fast Commit : 사용자가 요구한 갱신 사항을 휘발성인 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록하지 않았더라도 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미로 Fast Commit이라는 용어를 사용커밋 정보가 로그파일에 기록돼 있기만 하면, 인스턴스 Crash가 발생하더라도 Redo 로그를 이용해 언제든 복구 가능하므로 사용자 프로세스는 안심하고 커밋을 완료할 수 있다.
- Write Ahead Logging : 버퍼캐시 블록을 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 하며, DBWR가 버퍼캐시의 Dirty 블록들을 데이터 파일에 기록하기 전에 먼저 LGWR 가 해당 Redo 엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야 함.

**메모리 캐시에 대한 설명**

- DB 버퍼 캐시 : 테이블 블록, 인덱스 블록, Undo 블록을 캐싱
- 라이브러리 캐시 : SQL, DB 저장형 함수/프로시저, 트리거를 캐싱
- 딕셔너리 캐시 : 테이블 정보, 인덱스 정보, 데이터파일 정보, 시퀀스 등을 캐싱
- 결과 캐시 : SQL 결과 집합을 캐싱

**버퍼 블록의 상태**

- 모든 버퍼캐시 블록은 아래 세 가지 중 하나의 상태에 놓인다.
- Free 버퍼 : 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는 상태(Clean 버퍼)이거나, 데이터가 담겼지만 데이터 파일과 서로 동기화 돼 있는 상태여서 언제든지 덮어써도 무방한 버퍼 블록을 말한다. 오라클이 데이터 파일로부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 한다. Free 상태인 버퍼에 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀐다.
- Dirty 버퍼 : 버퍼캐시에 적재된 이후 변경이 발생했지만, 아직 데이터 파일에 기록하지 않아 동기화가 필요한 버퍼 블록을 말한다. 이 버퍼 블록들을 다른 데이터 블록을 위해 재사용하려면 데이터 파일에 먼저 기록해야 하며, 그 순간 Free 버퍼로 상태가 바뀐다.
- Pinned 버퍼 : 읽기 또는 쓰기 작업을 위해 현재 액세스되고 있는 버퍼 블록을 말한다.