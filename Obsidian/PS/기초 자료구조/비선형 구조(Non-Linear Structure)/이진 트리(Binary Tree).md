### 정의
- 모든 노드의 자식 노드의 개수가 2개 이하인 트리
- 트리의 가장 간단한 형태이다
![](https://i.imgur.com/mZcsZJ6.png)


### 종류
- 정 이진 트리(full binary tree) : 모든 노드의 자식 노드의 개수가 0 또는 2인 형태
- 포화 이진 트리(perfect binary tree) : 모든 리프 노드의 높이가 같고, 리프 노드가 아닌 노드는 모두 2개의 자식을 가진 형태
- 완전 이진 트리(complete binary tree) : 최하위 레벨에 위치하지 않은 노드들이 모두 채워져있고, 최하위 레벨에 있는 노드들이 왼쪽에서 부터 채워진 형태

### 성질
- 일반적으로 비선형 구조인 이진트리는 자식들의 포인터를 갖도록 구현되지만 완전 이진 트리의 경우 모든 노드가 채워져있기 때문에 배열을 사용해서 구현하기도 함
    ```cpp
    // T는 자료형
    T tree[50];
    
    // node는 트리에서 가리키고 있는 노드의 위치
    // node가 1이면 루트 노드
    int node = 1;
    
    // node << 1은 왼쪽 자식 노드
    node = node << 1;
    or 
    node = node * 2;
    
    // node << 1 | 1은 오른쪽 자식 노드
    node = node << 1 | 1;
    or 
    node = node * 2 + 1;
    
    // node >> 1은 부모 노드
    node = node >> 1;
    or
    node = node / 2;
    ```

### 활용
- 이진 탐색 트리 : 왼쪽 자식 노드에는 현재 노드의 값보다 작은 값들만, 오른쪽 자식 노드에는 큰 값들만 있는 트리 ⇒ 탐색을 할 때 반대쪽 자식은 탐색할 필요가 없으므로 탐색/삽입/삭제 모두 시간 복잡도가 ${O(logN)}$이다(운이 않좋아 일렬로 만들어지게 되면 최대 ${O(N)}$이 걸림).
![](https://i.imgur.com/VymTjNz.png)

- 스레드 이진 트리 : 왼쪽, 혹은 오른쪽 자식 노드가 없는 노드의 링크를 중위탐색시 선행노드, 혹은 후속노드로 연결해놓은 이진 트리 ⇒ 자식 노드인지 선행/후속 노드인지 표기하는 플래그가 추가된다.
![](https://i.imgur.com/uqV54Uv.png)

- 힙 : 하위 페이지로 대체                                           
  [[힙(Heap)]]

### 변형

- AVL-tree : 가장 처음 나온 자가 균형 이진 탐색트리로 이진 탐색트리가 운이 않좋을 경우 ${O(N)}$의 시간이 걸리는 것을 보완한 트리. ⇒ 모든 상황에서 탐색/삽입/삭제의 시간 복잡도가 ${O(logN)}$이다.   모든 노드의 높이 차이를 1로 맞추기위해 각 연산을 수행 할 때 트리의 일부를 회전시킨다(균형은 red-black tree보다 잘 잡히지만, 삽입과 삭제가 느리고, 탐색 자체는 빠르다).
- Red-black tree : 자가 균형 이진 탐색 트리의 일종으로, 노드에 색깔 속성이 붙은 트리이다. 이상적인 상황에서나 최악의 상황에서 탐색/삽입/삭제 모두 시간 복잡도가 ${O(logN)}$이다. 다른 트리와 달리 자식이 하나도 없는 노드의 끝에 널 리프 노드를 붙인다.
  만족해야하는 조건은 5가지가 있다.
	- 모든 노드는 레드 아니면 블랙이다.
    - 루트 노드는 블랙이다.
    - 모든 널 리프 노드는 블랙이다.
    - 레드 노드의 자식노드는 언제나 블랙이다(블랙은 연속 가능, 레드는 연속 불가능).
    - 임의의 한 노드에서 널 리프 노드까지 도달하는 모든 경로에는 널 리프 노드를 제외하고 항상 같은 수의 블랙 노드가 있다.   
    c++ STL의 set, map은 레드블랙 트리를 이용하여 구현되었다.